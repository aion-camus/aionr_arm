// This file is generated by rust-protobuf 2.1.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct t_Contract {
    // message fields
    pub code: ::std::string::String,
    pub error: ::std::string::String,
    pub source: ::std::string::String,
    pub compilerVersion: ::std::string::String,
    pub compilerOptions: ::std::string::String,
    pub abiDef: ::std::vec::Vec<u8>,
    pub userDoc: ::std::vec::Vec<u8>,
    pub devDoc: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_Contract {
    pub fn new() -> t_Contract {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    pub fn get_code(&self) -> &str {
        &self.code
    }

    // string error = 2;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }

    // string source = 3;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    pub fn get_source(&self) -> &str {
        &self.source
    }

    // string compilerVersion = 4;

    pub fn clear_compilerVersion(&mut self) {
        self.compilerVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilerVersion(&mut self, v: ::std::string::String) {
        self.compilerVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilerVersion(&mut self) -> &mut ::std::string::String {
        &mut self.compilerVersion
    }

    // Take field
    pub fn take_compilerVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compilerVersion, ::std::string::String::new())
    }

    pub fn get_compilerVersion(&self) -> &str {
        &self.compilerVersion
    }

    // string compilerOptions = 5;

    pub fn clear_compilerOptions(&mut self) {
        self.compilerOptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_compilerOptions(&mut self, v: ::std::string::String) {
        self.compilerOptions = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compilerOptions(&mut self) -> &mut ::std::string::String {
        &mut self.compilerOptions
    }

    // Take field
    pub fn take_compilerOptions(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compilerOptions, ::std::string::String::new())
    }

    pub fn get_compilerOptions(&self) -> &str {
        &self.compilerOptions
    }

    // bytes abiDef = 6;

    pub fn clear_abiDef(&mut self) {
        self.abiDef.clear();
    }

    // Param is passed by value, moved
    pub fn set_abiDef(&mut self, v: ::std::vec::Vec<u8>) {
        self.abiDef = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_abiDef(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.abiDef
    }

    // Take field
    pub fn take_abiDef(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.abiDef, ::std::vec::Vec::new())
    }

    pub fn get_abiDef(&self) -> &[u8] {
        &self.abiDef
    }

    // bytes userDoc = 7;

    pub fn clear_userDoc(&mut self) {
        self.userDoc.clear();
    }

    // Param is passed by value, moved
    pub fn set_userDoc(&mut self, v: ::std::vec::Vec<u8>) {
        self.userDoc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userDoc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userDoc
    }

    // Take field
    pub fn take_userDoc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userDoc, ::std::vec::Vec::new())
    }

    pub fn get_userDoc(&self) -> &[u8] {
        &self.userDoc
    }

    // bytes devDoc = 8;

    pub fn clear_devDoc(&mut self) {
        self.devDoc.clear();
    }

    // Param is passed by value, moved
    pub fn set_devDoc(&mut self, v: ::std::vec::Vec<u8>) {
        self.devDoc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devDoc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.devDoc
    }

    // Take field
    pub fn take_devDoc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.devDoc, ::std::vec::Vec::new())
    }

    pub fn get_devDoc(&self) -> &[u8] {
        &self.devDoc
    }
}

impl ::protobuf::Message for t_Contract {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compilerVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compilerOptions)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.abiDef)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userDoc)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.devDoc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source);
        }
        if !self.compilerVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.compilerVersion);
        }
        if !self.compilerOptions.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilerOptions);
        }
        if !self.abiDef.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.abiDef);
        }
        if !self.userDoc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.userDoc);
        }
        if !self.devDoc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.devDoc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        if !self.source.is_empty() {
            os.write_string(3, &self.source)?;
        }
        if !self.compilerVersion.is_empty() {
            os.write_string(4, &self.compilerVersion)?;
        }
        if !self.compilerOptions.is_empty() {
            os.write_string(5, &self.compilerOptions)?;
        }
        if !self.abiDef.is_empty() {
            os.write_bytes(6, &self.abiDef)?;
        }
        if !self.userDoc.is_empty() {
            os.write_bytes(7, &self.userDoc)?;
        }
        if !self.devDoc.is_empty() {
            os.write_bytes(8, &self.devDoc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_Contract {
        t_Contract::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    |m: &t_Contract| { &m.code },
                    |m: &mut t_Contract| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &t_Contract| { &m.error },
                    |m: &mut t_Contract| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &t_Contract| { &m.source },
                    |m: &mut t_Contract| { &mut m.source },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "compilerVersion",
                    |m: &t_Contract| { &m.compilerVersion },
                    |m: &mut t_Contract| { &mut m.compilerVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "compilerOptions",
                    |m: &t_Contract| { &m.compilerOptions },
                    |m: &mut t_Contract| { &mut m.compilerOptions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "abiDef",
                    |m: &t_Contract| { &m.abiDef },
                    |m: &mut t_Contract| { &mut m.abiDef },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "userDoc",
                    |m: &t_Contract| { &m.userDoc },
                    |m: &mut t_Contract| { &mut m.userDoc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "devDoc",
                    |m: &t_Contract| { &m.devDoc },
                    |m: &mut t_Contract| { &mut m.devDoc },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_Contract>(
                    "t_Contract",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_Contract {
        static mut instance: ::protobuf::lazy::Lazy<t_Contract> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_Contract,
        };
        unsafe {
            instance.get(t_Contract::new)
        }
    }
}

impl ::protobuf::Clear for t_Contract {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_error();
        self.clear_source();
        self.clear_compilerVersion();
        self.clear_compilerOptions();
        self.clear_abiDef();
        self.clear_userDoc();
        self.clear_devDoc();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_Contract {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_Contract {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_AionTx {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub nrgConsumed: u64,
    pub nrgPrice: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_AionTx {
    pub fn new() -> t_AionTx {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }

    // bytes from = 2;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 3;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // bytes data = 5;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes nonce = 6;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // uint64 nrgConsumed = 7;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgPrice = 8;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }
}

impl ::protobuf::Message for t_AionTx {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.to);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.nonce);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(8, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(2, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(3, &self.to)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(6, &self.nonce)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(7, self.nrgConsumed)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(8, self.nrgPrice)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_AionTx {
        t_AionTx::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &t_AionTx| { &m.txHash },
                    |m: &mut t_AionTx| { &mut m.txHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &t_AionTx| { &m.from },
                    |m: &mut t_AionTx| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &t_AionTx| { &m.to },
                    |m: &mut t_AionTx| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &t_AionTx| { &m.value },
                    |m: &mut t_AionTx| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &t_AionTx| { &m.data },
                    |m: &mut t_AionTx| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &t_AionTx| { &m.nonce },
                    |m: &mut t_AionTx| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &t_AionTx| { &m.nrgConsumed },
                    |m: &mut t_AionTx| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &t_AionTx| { &m.nrgPrice },
                    |m: &mut t_AionTx| { &mut m.nrgPrice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_AionTx>(
                    "t_AionTx",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_AionTx {
        static mut instance: ::protobuf::lazy::Lazy<t_AionTx> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_AionTx,
        };
        unsafe {
            instance.get(t_AionTx::new)
        }
    }
}

impl ::protobuf::Clear for t_AionTx {
    fn clear(&mut self) {
        self.clear_txHash();
        self.clear_from();
        self.clear_to();
        self.clear_value();
        self.clear_data();
        self.clear_nonce();
        self.clear_nrgConsumed();
        self.clear_nrgPrice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_AionTx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_AionTx {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_Node {
    // message fields
    pub blockNumber: u64,
    pub nodeId: ::std::string::String,
    pub remote_p2p_ip: ::std::string::String,
    pub remote_p2p_port: u32,
    pub latency: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_Node {
    pub fn new() -> t_Node {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // string nodeId = 2;

    pub fn clear_nodeId(&mut self) {
        self.nodeId.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeId(&mut self, v: ::std::string::String) {
        self.nodeId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeId(&mut self) -> &mut ::std::string::String {
        &mut self.nodeId
    }

    // Take field
    pub fn take_nodeId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nodeId, ::std::string::String::new())
    }

    pub fn get_nodeId(&self) -> &str {
        &self.nodeId
    }

    // string remote_p2p_ip = 3;

    pub fn clear_remote_p2p_ip(&mut self) {
        self.remote_p2p_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_remote_p2p_ip(&mut self, v: ::std::string::String) {
        self.remote_p2p_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_remote_p2p_ip(&mut self) -> &mut ::std::string::String {
        &mut self.remote_p2p_ip
    }

    // Take field
    pub fn take_remote_p2p_ip(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.remote_p2p_ip, ::std::string::String::new())
    }

    pub fn get_remote_p2p_ip(&self) -> &str {
        &self.remote_p2p_ip
    }

    // uint32 remote_p2p_port = 4;

    pub fn clear_remote_p2p_port(&mut self) {
        self.remote_p2p_port = 0;
    }

    // Param is passed by value, moved
    pub fn set_remote_p2p_port(&mut self, v: u32) {
        self.remote_p2p_port = v;
    }

    pub fn get_remote_p2p_port(&self) -> u32 {
        self.remote_p2p_port
    }

    // uint32 latency = 5;

    pub fn clear_latency(&mut self) {
        self.latency = 0;
    }

    // Param is passed by value, moved
    pub fn set_latency(&mut self, v: u32) {
        self.latency = v;
    }

    pub fn get_latency(&self) -> u32 {
        self.latency
    }
}

impl ::protobuf::Message for t_Node {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nodeId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.remote_p2p_ip)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.remote_p2p_port = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.latency = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.nodeId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.nodeId);
        }
        if !self.remote_p2p_ip.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.remote_p2p_ip);
        }
        if self.remote_p2p_port != 0 {
            my_size += ::protobuf::rt::value_size(4, self.remote_p2p_port, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latency != 0 {
            my_size += ::protobuf::rt::value_size(5, self.latency, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if !self.nodeId.is_empty() {
            os.write_string(2, &self.nodeId)?;
        }
        if !self.remote_p2p_ip.is_empty() {
            os.write_string(3, &self.remote_p2p_ip)?;
        }
        if self.remote_p2p_port != 0 {
            os.write_uint32(4, self.remote_p2p_port)?;
        }
        if self.latency != 0 {
            os.write_uint32(5, self.latency)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_Node {
        t_Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &t_Node| { &m.blockNumber },
                    |m: &mut t_Node| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nodeId",
                    |m: &t_Node| { &m.nodeId },
                    |m: &mut t_Node| { &mut m.nodeId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "remote_p2p_ip",
                    |m: &t_Node| { &m.remote_p2p_ip },
                    |m: &mut t_Node| { &mut m.remote_p2p_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "remote_p2p_port",
                    |m: &t_Node| { &m.remote_p2p_port },
                    |m: &mut t_Node| { &mut m.remote_p2p_port },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "latency",
                    |m: &t_Node| { &m.latency },
                    |m: &mut t_Node| { &mut m.latency },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_Node>(
                    "t_Node",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_Node {
        static mut instance: ::protobuf::lazy::Lazy<t_Node> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_Node,
        };
        unsafe {
            instance.get(t_Node::new)
        }
    }
}

impl ::protobuf::Clear for t_Node {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_nodeId();
        self.clear_remote_p2p_ip();
        self.clear_remote_p2p_port();
        self.clear_latency();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_Node {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_LgEle {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub topics: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_LgEle {
    pub fn new() -> t_LgEle {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // repeated string topics = 3;

    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    pub fn get_topics(&self) -> &[::std::string::String] {
        &self.topics
    }
}

impl ::protobuf::Message for t_LgEle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topics)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        for value in &self.topics {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        for v in &self.topics {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_LgEle {
        t_LgEle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &t_LgEle| { &m.address },
                    |m: &mut t_LgEle| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &t_LgEle| { &m.data },
                    |m: &mut t_LgEle| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topics",
                    |m: &t_LgEle| { &m.topics },
                    |m: &mut t_LgEle| { &mut m.topics },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_LgEle>(
                    "t_LgEle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_LgEle {
        static mut instance: ::protobuf::lazy::Lazy<t_LgEle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_LgEle,
        };
        unsafe {
            instance.get(t_LgEle::new)
        }
    }
}

impl ::protobuf::Clear for t_LgEle {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_data();
        self.clear_topics();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_LgEle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_LgEle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_FilterCt {
    // message fields
    pub from: ::std::string::String,
    pub to: ::std::string::String,
    pub contractAddr: ::std::vec::Vec<u8>,
    pub addresses: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub topics: ::protobuf::RepeatedField<::std::string::String>,
    pub expireTime: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_FilterCt {
    pub fn new() -> t_FilterCt {
        ::std::default::Default::default()
    }

    // string from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from, ::std::string::String::new())
    }

    pub fn get_from(&self) -> &str {
        &self.from
    }

    // string to = 2;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.to, ::std::string::String::new())
    }

    pub fn get_to(&self) -> &str {
        &self.to
    }

    // bytes contractAddr = 3;

    pub fn clear_contractAddr(&mut self) {
        self.contractAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.contractAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contractAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contractAddr
    }

    // Take field
    pub fn take_contractAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contractAddr, ::std::vec::Vec::new())
    }

    pub fn get_contractAddr(&self) -> &[u8] {
        &self.contractAddr
    }

    // repeated bytes addresses = 4;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[::std::vec::Vec<u8>] {
        &self.addresses
    }

    // repeated string topics = 5;

    pub fn clear_topics(&mut self) {
        self.topics.clear();
    }

    // Param is passed by value, moved
    pub fn set_topics(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topics = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topics(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topics
    }

    // Take field
    pub fn take_topics(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topics, ::protobuf::RepeatedField::new())
    }

    pub fn get_topics(&self) -> &[::std::string::String] {
        &self.topics
    }

    // uint64 expireTime = 6;

    pub fn clear_expireTime(&mut self) {
        self.expireTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_expireTime(&mut self, v: u64) {
        self.expireTime = v;
    }

    pub fn get_expireTime(&self) -> u64 {
        self.expireTime
    }
}

impl ::protobuf::Message for t_FilterCt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contractAddr)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.addresses)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topics)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.expireTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.to);
        }
        if !self.contractAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.contractAddr);
        }
        for value in &self.addresses {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in &self.topics {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if self.expireTime != 0 {
            my_size += ::protobuf::rt::value_size(6, self.expireTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_string(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_string(2, &self.to)?;
        }
        if !self.contractAddr.is_empty() {
            os.write_bytes(3, &self.contractAddr)?;
        }
        for v in &self.addresses {
            os.write_bytes(4, &v)?;
        };
        for v in &self.topics {
            os.write_string(5, &v)?;
        };
        if self.expireTime != 0 {
            os.write_uint64(6, self.expireTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_FilterCt {
        t_FilterCt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from",
                    |m: &t_FilterCt| { &m.from },
                    |m: &mut t_FilterCt| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "to",
                    |m: &t_FilterCt| { &m.to },
                    |m: &mut t_FilterCt| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contractAddr",
                    |m: &t_FilterCt| { &m.contractAddr },
                    |m: &mut t_FilterCt| { &mut m.contractAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "addresses",
                    |m: &t_FilterCt| { &m.addresses },
                    |m: &mut t_FilterCt| { &mut m.addresses },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "topics",
                    |m: &t_FilterCt| { &m.topics },
                    |m: &mut t_FilterCt| { &mut m.topics },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "expireTime",
                    |m: &t_FilterCt| { &m.expireTime },
                    |m: &mut t_FilterCt| { &mut m.expireTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_FilterCt>(
                    "t_FilterCt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_FilterCt {
        static mut instance: ::protobuf::lazy::Lazy<t_FilterCt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_FilterCt,
        };
        unsafe {
            instance.get(t_FilterCt::new)
        }
    }
}

impl ::protobuf::Clear for t_FilterCt {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_to();
        self.clear_contractAddr();
        self.clear_addresses();
        self.clear_topics();
        self.clear_expireTime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_FilterCt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_FilterCt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_EventCt {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub blockHash: ::std::vec::Vec<u8>,
    pub blockNumber: u64,
    pub logIndex: u32,
    pub eventName: ::std::string::String,
    pub removed: bool,
    pub txIndex: u32,
    pub txHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_EventCt {
    pub fn new() -> t_EventCt {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // bytes data = 2;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes blockHash = 3;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }

    // uint64 blockNumber = 4;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint32 logIndex = 5;

    pub fn clear_logIndex(&mut self) {
        self.logIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_logIndex(&mut self, v: u32) {
        self.logIndex = v;
    }

    pub fn get_logIndex(&self) -> u32 {
        self.logIndex
    }

    // string eventName = 6;

    pub fn clear_eventName(&mut self) {
        self.eventName.clear();
    }

    // Param is passed by value, moved
    pub fn set_eventName(&mut self, v: ::std::string::String) {
        self.eventName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventName(&mut self) -> &mut ::std::string::String {
        &mut self.eventName
    }

    // Take field
    pub fn take_eventName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.eventName, ::std::string::String::new())
    }

    pub fn get_eventName(&self) -> &str {
        &self.eventName
    }

    // bool removed = 7;

    pub fn clear_removed(&mut self) {
        self.removed = false;
    }

    // Param is passed by value, moved
    pub fn set_removed(&mut self, v: bool) {
        self.removed = v;
    }

    pub fn get_removed(&self) -> bool {
        self.removed
    }

    // uint32 txIndex = 8;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }

    // bytes txHash = 9;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }
}

impl ::protobuf::Message for t_EventCt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.logIndex = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.eventName)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.removed = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blockHash);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(4, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.logIndex != 0 {
            my_size += ::protobuf::rt::value_size(5, self.logIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.eventName.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.eventName);
        }
        if self.removed != false {
            my_size += 2;
        }
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(8, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.txHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if !self.blockHash.is_empty() {
            os.write_bytes(3, &self.blockHash)?;
        }
        if self.blockNumber != 0 {
            os.write_uint64(4, self.blockNumber)?;
        }
        if self.logIndex != 0 {
            os.write_uint32(5, self.logIndex)?;
        }
        if !self.eventName.is_empty() {
            os.write_string(6, &self.eventName)?;
        }
        if self.removed != false {
            os.write_bool(7, self.removed)?;
        }
        if self.txIndex != 0 {
            os.write_uint32(8, self.txIndex)?;
        }
        if !self.txHash.is_empty() {
            os.write_bytes(9, &self.txHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_EventCt {
        t_EventCt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &t_EventCt| { &m.address },
                    |m: &mut t_EventCt| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &t_EventCt| { &m.data },
                    |m: &mut t_EventCt| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &t_EventCt| { &m.blockHash },
                    |m: &mut t_EventCt| { &mut m.blockHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &t_EventCt| { &m.blockNumber },
                    |m: &mut t_EventCt| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "logIndex",
                    |m: &t_EventCt| { &m.logIndex },
                    |m: &mut t_EventCt| { &mut m.logIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "eventName",
                    |m: &t_EventCt| { &m.eventName },
                    |m: &mut t_EventCt| { &mut m.eventName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "removed",
                    |m: &t_EventCt| { &m.removed },
                    |m: &mut t_EventCt| { &mut m.removed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &t_EventCt| { &m.txIndex },
                    |m: &mut t_EventCt| { &mut m.txIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &t_EventCt| { &m.txHash },
                    |m: &mut t_EventCt| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_EventCt>(
                    "t_EventCt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_EventCt {
        static mut instance: ::protobuf::lazy::Lazy<t_EventCt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_EventCt,
        };
        unsafe {
            instance.get(t_EventCt::new)
        }
    }
}

impl ::protobuf::Clear for t_EventCt {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_data();
        self.clear_blockHash();
        self.clear_blockNumber();
        self.clear_logIndex();
        self.clear_eventName();
        self.clear_removed();
        self.clear_txIndex();
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_EventCt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_EventCt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_BlockDetail {
    // message fields
    pub blockNumber: u64,
    pub timestamp: u64,
    pub nrgConsumed: u64,
    pub nrgLimit: u64,
    pub parentHash: ::std::vec::Vec<u8>,
    pub minerAddress: ::std::vec::Vec<u8>,
    pub stateRoot: ::std::vec::Vec<u8>,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub receiptTrieRoot: ::std::vec::Vec<u8>,
    pub logsBloom: ::std::vec::Vec<u8>,
    pub difficulty: ::std::vec::Vec<u8>,
    pub totalDifficulty: ::std::vec::Vec<u8>,
    pub extraData: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub solution: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub size: u32,
    pub tx: ::protobuf::RepeatedField<t_TxDetail>,
    pub blockTime: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_BlockDetail {
    pub fn new() -> t_BlockDetail {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 nrgConsumed = 3;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgLimit = 4;

    pub fn clear_nrgLimit(&mut self) {
        self.nrgLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgLimit(&mut self, v: u64) {
        self.nrgLimit = v;
    }

    pub fn get_nrgLimit(&self) -> u64 {
        self.nrgLimit
    }

    // bytes parentHash = 5;

    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }

    // bytes minerAddress = 6;

    pub fn clear_minerAddress(&mut self) {
        self.minerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_minerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.minerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.minerAddress
    }

    // Take field
    pub fn take_minerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.minerAddress, ::std::vec::Vec::new())
    }

    pub fn get_minerAddress(&self) -> &[u8] {
        &self.minerAddress
    }

    // bytes stateRoot = 7;

    pub fn clear_stateRoot(&mut self) {
        self.stateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_stateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.stateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stateRoot
    }

    // Take field
    pub fn take_stateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stateRoot, ::std::vec::Vec::new())
    }

    pub fn get_stateRoot(&self) -> &[u8] {
        &self.stateRoot
    }

    // bytes txTrieRoot = 8;

    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }

    // bytes receiptTrieRoot = 9;

    pub fn clear_receiptTrieRoot(&mut self) {
        self.receiptTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiptTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiptTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiptTrieRoot
    }

    // Take field
    pub fn take_receiptTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiptTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_receiptTrieRoot(&self) -> &[u8] {
        &self.receiptTrieRoot
    }

    // bytes logsBloom = 10;

    pub fn clear_logsBloom(&mut self) {
        self.logsBloom.clear();
    }

    // Param is passed by value, moved
    pub fn set_logsBloom(&mut self, v: ::std::vec::Vec<u8>) {
        self.logsBloom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logsBloom(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logsBloom
    }

    // Take field
    pub fn take_logsBloom(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logsBloom, ::std::vec::Vec::new())
    }

    pub fn get_logsBloom(&self) -> &[u8] {
        &self.logsBloom
    }

    // bytes difficulty = 11;

    pub fn clear_difficulty(&mut self) {
        self.difficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.difficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_difficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.difficulty
    }

    // Take field
    pub fn take_difficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.difficulty, ::std::vec::Vec::new())
    }

    pub fn get_difficulty(&self) -> &[u8] {
        &self.difficulty
    }

    // bytes totalDifficulty = 12;

    pub fn clear_totalDifficulty(&mut self) {
        self.totalDifficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalDifficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.totalDifficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalDifficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.totalDifficulty
    }

    // Take field
    pub fn take_totalDifficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.totalDifficulty, ::std::vec::Vec::new())
    }

    pub fn get_totalDifficulty(&self) -> &[u8] {
        &self.totalDifficulty
    }

    // bytes extraData = 13;

    pub fn clear_extraData(&mut self) {
        self.extraData.clear();
    }

    // Param is passed by value, moved
    pub fn set_extraData(&mut self, v: ::std::vec::Vec<u8>) {
        self.extraData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extraData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extraData
    }

    // Take field
    pub fn take_extraData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extraData, ::std::vec::Vec::new())
    }

    pub fn get_extraData(&self) -> &[u8] {
        &self.extraData
    }

    // bytes nonce = 14;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes solution = 15;

    pub fn clear_solution(&mut self) {
        self.solution.clear();
    }

    // Param is passed by value, moved
    pub fn set_solution(&mut self, v: ::std::vec::Vec<u8>) {
        self.solution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solution(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.solution
    }

    // Take field
    pub fn take_solution(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.solution, ::std::vec::Vec::new())
    }

    pub fn get_solution(&self) -> &[u8] {
        &self.solution
    }

    // bytes hash = 16;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // uint32 size = 17;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    pub fn get_size(&self) -> u32 {
        self.size
    }

    // repeated .bp_api.t_TxDetail tx = 18;

    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: ::protobuf::RepeatedField<t_TxDetail>) {
        self.tx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx(&mut self) -> &mut ::protobuf::RepeatedField<t_TxDetail> {
        &mut self.tx
    }

    // Take field
    pub fn take_tx(&mut self) -> ::protobuf::RepeatedField<t_TxDetail> {
        ::std::mem::replace(&mut self.tx, ::protobuf::RepeatedField::new())
    }

    pub fn get_tx(&self) -> &[t_TxDetail] {
        &self.tx
    }

    // uint64 blockTime = 19;

    pub fn clear_blockTime(&mut self) {
        self.blockTime = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockTime(&mut self, v: u64) {
        self.blockTime = v;
    }

    pub fn get_blockTime(&self) -> u64 {
        self.blockTime
    }
}

impl ::protobuf::Message for t_BlockDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.tx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.minerAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stateRoot)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiptTrieRoot)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logsBloom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.difficulty)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.totalDifficulty)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extraData)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.solution)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                18 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockTime = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nrgLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.parentHash);
        }
        if !self.minerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.minerAddress);
        }
        if !self.stateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.stateRoot);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.txTrieRoot);
        }
        if !self.receiptTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.receiptTrieRoot);
        }
        if !self.logsBloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.logsBloom);
        }
        if !self.difficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.difficulty);
        }
        if !self.totalDifficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.totalDifficulty);
        }
        if !self.extraData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.extraData);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.nonce);
        }
        if !self.solution.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.solution);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.hash);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(17, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tx {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.blockTime != 0 {
            my_size += ::protobuf::rt::value_size(19, self.blockTime, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(3, self.nrgConsumed)?;
        }
        if self.nrgLimit != 0 {
            os.write_uint64(4, self.nrgLimit)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(5, &self.parentHash)?;
        }
        if !self.minerAddress.is_empty() {
            os.write_bytes(6, &self.minerAddress)?;
        }
        if !self.stateRoot.is_empty() {
            os.write_bytes(7, &self.stateRoot)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(8, &self.txTrieRoot)?;
        }
        if !self.receiptTrieRoot.is_empty() {
            os.write_bytes(9, &self.receiptTrieRoot)?;
        }
        if !self.logsBloom.is_empty() {
            os.write_bytes(10, &self.logsBloom)?;
        }
        if !self.difficulty.is_empty() {
            os.write_bytes(11, &self.difficulty)?;
        }
        if !self.totalDifficulty.is_empty() {
            os.write_bytes(12, &self.totalDifficulty)?;
        }
        if !self.extraData.is_empty() {
            os.write_bytes(13, &self.extraData)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(14, &self.nonce)?;
        }
        if !self.solution.is_empty() {
            os.write_bytes(15, &self.solution)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(16, &self.hash)?;
        }
        if self.size != 0 {
            os.write_uint32(17, self.size)?;
        }
        for v in &self.tx {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.blockTime != 0 {
            os.write_uint64(19, self.blockTime)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_BlockDetail {
        t_BlockDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &t_BlockDetail| { &m.blockNumber },
                    |m: &mut t_BlockDetail| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &t_BlockDetail| { &m.timestamp },
                    |m: &mut t_BlockDetail| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &t_BlockDetail| { &m.nrgConsumed },
                    |m: &mut t_BlockDetail| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgLimit",
                    |m: &t_BlockDetail| { &m.nrgLimit },
                    |m: &mut t_BlockDetail| { &mut m.nrgLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parentHash",
                    |m: &t_BlockDetail| { &m.parentHash },
                    |m: &mut t_BlockDetail| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "minerAddress",
                    |m: &t_BlockDetail| { &m.minerAddress },
                    |m: &mut t_BlockDetail| { &mut m.minerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stateRoot",
                    |m: &t_BlockDetail| { &m.stateRoot },
                    |m: &mut t_BlockDetail| { &mut m.stateRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txTrieRoot",
                    |m: &t_BlockDetail| { &m.txTrieRoot },
                    |m: &mut t_BlockDetail| { &mut m.txTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiptTrieRoot",
                    |m: &t_BlockDetail| { &m.receiptTrieRoot },
                    |m: &mut t_BlockDetail| { &mut m.receiptTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "logsBloom",
                    |m: &t_BlockDetail| { &m.logsBloom },
                    |m: &mut t_BlockDetail| { &mut m.logsBloom },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "difficulty",
                    |m: &t_BlockDetail| { &m.difficulty },
                    |m: &mut t_BlockDetail| { &mut m.difficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "totalDifficulty",
                    |m: &t_BlockDetail| { &m.totalDifficulty },
                    |m: &mut t_BlockDetail| { &mut m.totalDifficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extraData",
                    |m: &t_BlockDetail| { &m.extraData },
                    |m: &mut t_BlockDetail| { &mut m.extraData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &t_BlockDetail| { &m.nonce },
                    |m: &mut t_BlockDetail| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "solution",
                    |m: &t_BlockDetail| { &m.solution },
                    |m: &mut t_BlockDetail| { &mut m.solution },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &t_BlockDetail| { &m.hash },
                    |m: &mut t_BlockDetail| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &t_BlockDetail| { &m.size },
                    |m: &mut t_BlockDetail| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_TxDetail>>(
                    "tx",
                    |m: &t_BlockDetail| { &m.tx },
                    |m: &mut t_BlockDetail| { &mut m.tx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockTime",
                    |m: &t_BlockDetail| { &m.blockTime },
                    |m: &mut t_BlockDetail| { &mut m.blockTime },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_BlockDetail>(
                    "t_BlockDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_BlockDetail {
        static mut instance: ::protobuf::lazy::Lazy<t_BlockDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_BlockDetail,
        };
        unsafe {
            instance.get(t_BlockDetail::new)
        }
    }
}

impl ::protobuf::Clear for t_BlockDetail {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_timestamp();
        self.clear_nrgConsumed();
        self.clear_nrgLimit();
        self.clear_parentHash();
        self.clear_minerAddress();
        self.clear_stateRoot();
        self.clear_txTrieRoot();
        self.clear_receiptTrieRoot();
        self.clear_logsBloom();
        self.clear_difficulty();
        self.clear_totalDifficulty();
        self.clear_extraData();
        self.clear_nonce();
        self.clear_solution();
        self.clear_hash();
        self.clear_size();
        self.clear_tx();
        self.clear_blockTime();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_BlockDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_BlockDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_TxDetail {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub nrgConsumed: u64,
    pub nrgPrice: u64,
    pub txIndex: u32,
    pub contract: ::std::vec::Vec<u8>,
    pub logs: ::protobuf::RepeatedField<t_LgEle>,
    pub timestamp: u64,
    pub error: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_TxDetail {
    pub fn new() -> t_TxDetail {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }

    // bytes from = 2;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 3;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // bytes data = 5;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes nonce = 6;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // uint64 nrgConsumed = 7;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgPrice = 8;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }

    // uint32 txIndex = 9;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }

    // bytes contract = 10;

    pub fn clear_contract(&mut self) {
        self.contract.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: ::std::vec::Vec<u8>) {
        self.contract = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contract
    }

    // Take field
    pub fn take_contract(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contract, ::std::vec::Vec::new())
    }

    pub fn get_contract(&self) -> &[u8] {
        &self.contract
    }

    // repeated .bp_api.t_LgEle logs = 11;

    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<t_LgEle>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<t_LgEle> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<t_LgEle> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    pub fn get_logs(&self) -> &[t_LgEle] {
        &self.logs
    }

    // uint64 timestamp = 12;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // string error = 13;

    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        &mut self.error
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.error, ::std::string::String::new())
    }

    pub fn get_error(&self) -> &str {
        &self.error
    }
}

impl ::protobuf::Message for t_TxDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contract)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.to);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.data);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.nonce);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(8, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(9, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.contract.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.contract);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(12, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(2, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(3, &self.to)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(5, &self.data)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(6, &self.nonce)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(7, self.nrgConsumed)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(8, self.nrgPrice)?;
        }
        if self.txIndex != 0 {
            os.write_uint32(9, self.txIndex)?;
        }
        if !self.contract.is_empty() {
            os.write_bytes(10, &self.contract)?;
        }
        for v in &self.logs {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.timestamp != 0 {
            os.write_uint64(12, self.timestamp)?;
        }
        if !self.error.is_empty() {
            os.write_string(13, &self.error)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_TxDetail {
        t_TxDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &t_TxDetail| { &m.txHash },
                    |m: &mut t_TxDetail| { &mut m.txHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &t_TxDetail| { &m.from },
                    |m: &mut t_TxDetail| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &t_TxDetail| { &m.to },
                    |m: &mut t_TxDetail| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &t_TxDetail| { &m.value },
                    |m: &mut t_TxDetail| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &t_TxDetail| { &m.data },
                    |m: &mut t_TxDetail| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &t_TxDetail| { &m.nonce },
                    |m: &mut t_TxDetail| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &t_TxDetail| { &m.nrgConsumed },
                    |m: &mut t_TxDetail| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &t_TxDetail| { &m.nrgPrice },
                    |m: &mut t_TxDetail| { &mut m.nrgPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &t_TxDetail| { &m.txIndex },
                    |m: &mut t_TxDetail| { &mut m.txIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contract",
                    |m: &t_TxDetail| { &m.contract },
                    |m: &mut t_TxDetail| { &mut m.contract },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_LgEle>>(
                    "logs",
                    |m: &t_TxDetail| { &m.logs },
                    |m: &mut t_TxDetail| { &mut m.logs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &t_TxDetail| { &m.timestamp },
                    |m: &mut t_TxDetail| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &t_TxDetail| { &m.error },
                    |m: &mut t_TxDetail| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_TxDetail>(
                    "t_TxDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_TxDetail {
        static mut instance: ::protobuf::lazy::Lazy<t_TxDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_TxDetail,
        };
        unsafe {
            instance.get(t_TxDetail::new)
        }
    }
}

impl ::protobuf::Clear for t_TxDetail {
    fn clear(&mut self) {
        self.clear_txHash();
        self.clear_from();
        self.clear_to();
        self.clear_value();
        self.clear_data();
        self.clear_nonce();
        self.clear_nrgConsumed();
        self.clear_nrgPrice();
        self.clear_txIndex();
        self.clear_contract();
        self.clear_logs();
        self.clear_timestamp();
        self.clear_error();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_TxDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_TxDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_AccountDetail {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub balance: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_AccountDetail {
    pub fn new() -> t_AccountDetail {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // bytes balance = 2;

    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::vec::Vec<u8>) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.balance, ::std::vec::Vec::new())
    }

    pub fn get_balance(&self) -> &[u8] {
        &self.balance
    }
}

impl ::protobuf::Message for t_AccountDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.balance.is_empty() {
            os.write_bytes(2, &self.balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_AccountDetail {
        t_AccountDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &t_AccountDetail| { &m.address },
                    |m: &mut t_AccountDetail| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "balance",
                    |m: &t_AccountDetail| { &m.balance },
                    |m: &mut t_AccountDetail| { &mut m.balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_AccountDetail>(
                    "t_AccountDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_AccountDetail {
        static mut instance: ::protobuf::lazy::Lazy<t_AccountDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_AccountDetail,
        };
        unsafe {
            instance.get(t_AccountDetail::new)
        }
    }
}

impl ::protobuf::Clear for t_AccountDetail {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_AccountDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_AccountDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_Block {
    // message fields
    pub blockNumber: u64,
    pub timestamp: u64,
    pub nrgConsumed: u64,
    pub nrgLimit: u64,
    pub parentHash: ::std::vec::Vec<u8>,
    pub minerAddress: ::std::vec::Vec<u8>,
    pub stateRoot: ::std::vec::Vec<u8>,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub receiptTrieRoot: ::std::vec::Vec<u8>,
    pub logsBloom: ::std::vec::Vec<u8>,
    pub difficulty: ::std::vec::Vec<u8>,
    pub totalDifficulty: ::std::vec::Vec<u8>,
    pub extraData: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub solution: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub size: u32,
    pub txHash: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_Block {
    pub fn new() -> t_Block {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 nrgConsumed = 3;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgLimit = 4;

    pub fn clear_nrgLimit(&mut self) {
        self.nrgLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgLimit(&mut self, v: u64) {
        self.nrgLimit = v;
    }

    pub fn get_nrgLimit(&self) -> u64 {
        self.nrgLimit
    }

    // bytes parentHash = 5;

    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }

    // bytes minerAddress = 6;

    pub fn clear_minerAddress(&mut self) {
        self.minerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_minerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.minerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.minerAddress
    }

    // Take field
    pub fn take_minerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.minerAddress, ::std::vec::Vec::new())
    }

    pub fn get_minerAddress(&self) -> &[u8] {
        &self.minerAddress
    }

    // bytes stateRoot = 7;

    pub fn clear_stateRoot(&mut self) {
        self.stateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_stateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.stateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stateRoot
    }

    // Take field
    pub fn take_stateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stateRoot, ::std::vec::Vec::new())
    }

    pub fn get_stateRoot(&self) -> &[u8] {
        &self.stateRoot
    }

    // bytes txTrieRoot = 8;

    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }

    // bytes receiptTrieRoot = 9;

    pub fn clear_receiptTrieRoot(&mut self) {
        self.receiptTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiptTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiptTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiptTrieRoot
    }

    // Take field
    pub fn take_receiptTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiptTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_receiptTrieRoot(&self) -> &[u8] {
        &self.receiptTrieRoot
    }

    // bytes logsBloom = 10;

    pub fn clear_logsBloom(&mut self) {
        self.logsBloom.clear();
    }

    // Param is passed by value, moved
    pub fn set_logsBloom(&mut self, v: ::std::vec::Vec<u8>) {
        self.logsBloom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logsBloom(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logsBloom
    }

    // Take field
    pub fn take_logsBloom(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logsBloom, ::std::vec::Vec::new())
    }

    pub fn get_logsBloom(&self) -> &[u8] {
        &self.logsBloom
    }

    // bytes difficulty = 11;

    pub fn clear_difficulty(&mut self) {
        self.difficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.difficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_difficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.difficulty
    }

    // Take field
    pub fn take_difficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.difficulty, ::std::vec::Vec::new())
    }

    pub fn get_difficulty(&self) -> &[u8] {
        &self.difficulty
    }

    // bytes totalDifficulty = 12;

    pub fn clear_totalDifficulty(&mut self) {
        self.totalDifficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalDifficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.totalDifficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalDifficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.totalDifficulty
    }

    // Take field
    pub fn take_totalDifficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.totalDifficulty, ::std::vec::Vec::new())
    }

    pub fn get_totalDifficulty(&self) -> &[u8] {
        &self.totalDifficulty
    }

    // bytes extraData = 13;

    pub fn clear_extraData(&mut self) {
        self.extraData.clear();
    }

    // Param is passed by value, moved
    pub fn set_extraData(&mut self, v: ::std::vec::Vec<u8>) {
        self.extraData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extraData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extraData
    }

    // Take field
    pub fn take_extraData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extraData, ::std::vec::Vec::new())
    }

    pub fn get_extraData(&self) -> &[u8] {
        &self.extraData
    }

    // bytes nonce = 14;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes solution = 15;

    pub fn clear_solution(&mut self) {
        self.solution.clear();
    }

    // Param is passed by value, moved
    pub fn set_solution(&mut self, v: ::std::vec::Vec<u8>) {
        self.solution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solution(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.solution
    }

    // Take field
    pub fn take_solution(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.solution, ::std::vec::Vec::new())
    }

    pub fn get_solution(&self) -> &[u8] {
        &self.solution
    }

    // bytes hash = 16;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // uint32 size = 17;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    pub fn get_size(&self) -> u32 {
        self.size
    }

    // repeated bytes txHash = 18;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txHash(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.txHash, ::protobuf::RepeatedField::new())
    }

    pub fn get_txHash(&self) -> &[::std::vec::Vec<u8>] {
        &self.txHash
    }
}

impl ::protobuf::Message for t_Block {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.minerAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stateRoot)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiptTrieRoot)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logsBloom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.difficulty)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.totalDifficulty)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extraData)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.solution)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                18 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nrgLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.parentHash);
        }
        if !self.minerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.minerAddress);
        }
        if !self.stateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.stateRoot);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.txTrieRoot);
        }
        if !self.receiptTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.receiptTrieRoot);
        }
        if !self.logsBloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.logsBloom);
        }
        if !self.difficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.difficulty);
        }
        if !self.totalDifficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.totalDifficulty);
        }
        if !self.extraData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.extraData);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.nonce);
        }
        if !self.solution.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.solution);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.hash);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(17, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.txHash {
            my_size += ::protobuf::rt::bytes_size(18, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(3, self.nrgConsumed)?;
        }
        if self.nrgLimit != 0 {
            os.write_uint64(4, self.nrgLimit)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(5, &self.parentHash)?;
        }
        if !self.minerAddress.is_empty() {
            os.write_bytes(6, &self.minerAddress)?;
        }
        if !self.stateRoot.is_empty() {
            os.write_bytes(7, &self.stateRoot)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(8, &self.txTrieRoot)?;
        }
        if !self.receiptTrieRoot.is_empty() {
            os.write_bytes(9, &self.receiptTrieRoot)?;
        }
        if !self.logsBloom.is_empty() {
            os.write_bytes(10, &self.logsBloom)?;
        }
        if !self.difficulty.is_empty() {
            os.write_bytes(11, &self.difficulty)?;
        }
        if !self.totalDifficulty.is_empty() {
            os.write_bytes(12, &self.totalDifficulty)?;
        }
        if !self.extraData.is_empty() {
            os.write_bytes(13, &self.extraData)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(14, &self.nonce)?;
        }
        if !self.solution.is_empty() {
            os.write_bytes(15, &self.solution)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(16, &self.hash)?;
        }
        if self.size != 0 {
            os.write_uint32(17, self.size)?;
        }
        for v in &self.txHash {
            os.write_bytes(18, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_Block {
        t_Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &t_Block| { &m.blockNumber },
                    |m: &mut t_Block| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &t_Block| { &m.timestamp },
                    |m: &mut t_Block| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &t_Block| { &m.nrgConsumed },
                    |m: &mut t_Block| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgLimit",
                    |m: &t_Block| { &m.nrgLimit },
                    |m: &mut t_Block| { &mut m.nrgLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parentHash",
                    |m: &t_Block| { &m.parentHash },
                    |m: &mut t_Block| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "minerAddress",
                    |m: &t_Block| { &m.minerAddress },
                    |m: &mut t_Block| { &mut m.minerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stateRoot",
                    |m: &t_Block| { &m.stateRoot },
                    |m: &mut t_Block| { &mut m.stateRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txTrieRoot",
                    |m: &t_Block| { &m.txTrieRoot },
                    |m: &mut t_Block| { &mut m.txTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiptTrieRoot",
                    |m: &t_Block| { &m.receiptTrieRoot },
                    |m: &mut t_Block| { &mut m.receiptTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "logsBloom",
                    |m: &t_Block| { &m.logsBloom },
                    |m: &mut t_Block| { &mut m.logsBloom },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "difficulty",
                    |m: &t_Block| { &m.difficulty },
                    |m: &mut t_Block| { &mut m.difficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "totalDifficulty",
                    |m: &t_Block| { &m.totalDifficulty },
                    |m: &mut t_Block| { &mut m.totalDifficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extraData",
                    |m: &t_Block| { &m.extraData },
                    |m: &mut t_Block| { &mut m.extraData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &t_Block| { &m.nonce },
                    |m: &mut t_Block| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "solution",
                    |m: &t_Block| { &m.solution },
                    |m: &mut t_Block| { &mut m.solution },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &t_Block| { &m.hash },
                    |m: &mut t_Block| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &t_Block| { &m.size },
                    |m: &mut t_Block| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &t_Block| { &m.txHash },
                    |m: &mut t_Block| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_Block>(
                    "t_Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_Block {
        static mut instance: ::protobuf::lazy::Lazy<t_Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_Block,
        };
        unsafe {
            instance.get(t_Block::new)
        }
    }
}

impl ::protobuf::Clear for t_Block {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_timestamp();
        self.clear_nrgConsumed();
        self.clear_nrgLimit();
        self.clear_parentHash();
        self.clear_minerAddress();
        self.clear_stateRoot();
        self.clear_txTrieRoot();
        self.clear_receiptTrieRoot();
        self.clear_logsBloom();
        self.clear_difficulty();
        self.clear_totalDifficulty();
        self.clear_extraData();
        self.clear_nonce();
        self.clear_solution();
        self.clear_hash();
        self.clear_size();
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_BlockSql {
    // message fields
    pub blockNumber: u64,
    pub blockHash: ::std::string::String,
    pub parentHash: ::std::string::String,
    pub block: ::std::string::String,
    pub tx: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_BlockSql {
    pub fn new() -> t_BlockSql {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // string blockHash = 2;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::string::String) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::string::String {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.blockHash, ::std::string::String::new())
    }

    pub fn get_blockHash(&self) -> &str {
        &self.blockHash
    }

    // string parentHash = 3;

    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::string::String) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::string::String {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parentHash, ::std::string::String::new())
    }

    pub fn get_parentHash(&self) -> &str {
        &self.parentHash
    }

    // string block = 4;

    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: ::std::string::String) {
        self.block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut ::std::string::String {
        &mut self.block
    }

    // Take field
    pub fn take_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.block, ::std::string::String::new())
    }

    pub fn get_block(&self) -> &str {
        &self.block
    }

    // repeated string tx = 5;

    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tx
    }

    // Take field
    pub fn take_tx(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tx, ::protobuf::RepeatedField::new())
    }

    pub fn get_tx(&self) -> &[::std::string::String] {
        &self.tx
    }
}

impl ::protobuf::Message for t_BlockSql {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.blockHash)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parentHash)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.block)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.blockHash);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.parentHash);
        }
        if !self.block.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.block);
        }
        for value in &self.tx {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if !self.blockHash.is_empty() {
            os.write_string(2, &self.blockHash)?;
        }
        if !self.parentHash.is_empty() {
            os.write_string(3, &self.parentHash)?;
        }
        if !self.block.is_empty() {
            os.write_string(4, &self.block)?;
        }
        for v in &self.tx {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_BlockSql {
        t_BlockSql::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &t_BlockSql| { &m.blockNumber },
                    |m: &mut t_BlockSql| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockHash",
                    |m: &t_BlockSql| { &m.blockHash },
                    |m: &mut t_BlockSql| { &mut m.blockHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parentHash",
                    |m: &t_BlockSql| { &m.parentHash },
                    |m: &mut t_BlockSql| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "block",
                    |m: &t_BlockSql| { &m.block },
                    |m: &mut t_BlockSql| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tx",
                    |m: &t_BlockSql| { &m.tx },
                    |m: &mut t_BlockSql| { &mut m.tx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_BlockSql>(
                    "t_BlockSql",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_BlockSql {
        static mut instance: ::protobuf::lazy::Lazy<t_BlockSql> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_BlockSql,
        };
        unsafe {
            instance.get(t_BlockSql::new)
        }
    }
}

impl ::protobuf::Clear for t_BlockSql {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_blockHash();
        self.clear_parentHash();
        self.clear_block();
        self.clear_tx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_BlockSql {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_BlockSql {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_errormsg {
    // message fields
    pub errormsg: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_errormsg {
    pub fn new() -> rsp_errormsg {
        ::std::default::Default::default()
    }

    // string errormsg = 1;

    pub fn clear_errormsg(&mut self) {
        self.errormsg.clear();
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        &mut self.errormsg
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.errormsg, ::std::string::String::new())
    }

    pub fn get_errormsg(&self) -> &str {
        &self.errormsg
    }
}

impl ::protobuf::Message for rsp_errormsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.errormsg)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.errormsg.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.errormsg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.errormsg.is_empty() {
            os.write_string(1, &self.errormsg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_errormsg {
        rsp_errormsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "errormsg",
                    |m: &rsp_errormsg| { &m.errormsg },
                    |m: &mut rsp_errormsg| { &mut m.errormsg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_errormsg>(
                    "rsp_errormsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_errormsg {
        static mut instance: ::protobuf::lazy::Lazy<rsp_errormsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_errormsg,
        };
        unsafe {
            instance.get(rsp_errormsg::new)
        }
    }
}

impl ::protobuf::Clear for rsp_errormsg {
    fn clear(&mut self) {
        self.clear_errormsg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_errormsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_errormsg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_protocolVersion {
    // message fields
    pub kernel: ::std::string::String,
    pub net: ::std::string::String,
    pub api: ::std::string::String,
    pub vm: ::std::string::String,
    pub db: ::std::string::String,
    pub miner: ::std::string::String,
    pub txpool: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_protocolVersion {
    pub fn new() -> rsp_protocolVersion {
        ::std::default::Default::default()
    }

    // string kernel = 1;

    pub fn clear_kernel(&mut self) {
        self.kernel.clear();
    }

    // Param is passed by value, moved
    pub fn set_kernel(&mut self, v: ::std::string::String) {
        self.kernel = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernel(&mut self) -> &mut ::std::string::String {
        &mut self.kernel
    }

    // Take field
    pub fn take_kernel(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.kernel, ::std::string::String::new())
    }

    pub fn get_kernel(&self) -> &str {
        &self.kernel
    }

    // string net = 2;

    pub fn clear_net(&mut self) {
        self.net.clear();
    }

    // Param is passed by value, moved
    pub fn set_net(&mut self, v: ::std::string::String) {
        self.net = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net(&mut self) -> &mut ::std::string::String {
        &mut self.net
    }

    // Take field
    pub fn take_net(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.net, ::std::string::String::new())
    }

    pub fn get_net(&self) -> &str {
        &self.net
    }

    // string api = 3;

    pub fn clear_api(&mut self) {
        self.api.clear();
    }

    // Param is passed by value, moved
    pub fn set_api(&mut self, v: ::std::string::String) {
        self.api = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_api(&mut self) -> &mut ::std::string::String {
        &mut self.api
    }

    // Take field
    pub fn take_api(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.api, ::std::string::String::new())
    }

    pub fn get_api(&self) -> &str {
        &self.api
    }

    // string vm = 4;

    pub fn clear_vm(&mut self) {
        self.vm.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm(&mut self, v: ::std::string::String) {
        self.vm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm(&mut self) -> &mut ::std::string::String {
        &mut self.vm
    }

    // Take field
    pub fn take_vm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm, ::std::string::String::new())
    }

    pub fn get_vm(&self) -> &str {
        &self.vm
    }

    // string db = 5;

    pub fn clear_db(&mut self) {
        self.db.clear();
    }

    // Param is passed by value, moved
    pub fn set_db(&mut self, v: ::std::string::String) {
        self.db = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db(&mut self) -> &mut ::std::string::String {
        &mut self.db
    }

    // Take field
    pub fn take_db(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.db, ::std::string::String::new())
    }

    pub fn get_db(&self) -> &str {
        &self.db
    }

    // string miner = 6;

    pub fn clear_miner(&mut self) {
        self.miner.clear();
    }

    // Param is passed by value, moved
    pub fn set_miner(&mut self, v: ::std::string::String) {
        self.miner = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miner(&mut self) -> &mut ::std::string::String {
        &mut self.miner
    }

    // Take field
    pub fn take_miner(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.miner, ::std::string::String::new())
    }

    pub fn get_miner(&self) -> &str {
        &self.miner
    }

    // string txpool = 7;

    pub fn clear_txpool(&mut self) {
        self.txpool.clear();
    }

    // Param is passed by value, moved
    pub fn set_txpool(&mut self, v: ::std::string::String) {
        self.txpool = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txpool(&mut self) -> &mut ::std::string::String {
        &mut self.txpool
    }

    // Take field
    pub fn take_txpool(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txpool, ::std::string::String::new())
    }

    pub fn get_txpool(&self) -> &str {
        &self.txpool
    }
}

impl ::protobuf::Message for rsp_protocolVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.kernel)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.net)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.api)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vm)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.db)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.miner)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txpool)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.kernel.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.kernel);
        }
        if !self.net.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.net);
        }
        if !self.api.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.api);
        }
        if !self.vm.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.vm);
        }
        if !self.db.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.db);
        }
        if !self.miner.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.miner);
        }
        if !self.txpool.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.txpool);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.kernel.is_empty() {
            os.write_string(1, &self.kernel)?;
        }
        if !self.net.is_empty() {
            os.write_string(2, &self.net)?;
        }
        if !self.api.is_empty() {
            os.write_string(3, &self.api)?;
        }
        if !self.vm.is_empty() {
            os.write_string(4, &self.vm)?;
        }
        if !self.db.is_empty() {
            os.write_string(5, &self.db)?;
        }
        if !self.miner.is_empty() {
            os.write_string(6, &self.miner)?;
        }
        if !self.txpool.is_empty() {
            os.write_string(7, &self.txpool)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_protocolVersion {
        rsp_protocolVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "kernel",
                    |m: &rsp_protocolVersion| { &m.kernel },
                    |m: &mut rsp_protocolVersion| { &mut m.kernel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "net",
                    |m: &rsp_protocolVersion| { &m.net },
                    |m: &mut rsp_protocolVersion| { &mut m.net },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "api",
                    |m: &rsp_protocolVersion| { &m.api },
                    |m: &mut rsp_protocolVersion| { &mut m.api },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vm",
                    |m: &rsp_protocolVersion| { &m.vm },
                    |m: &mut rsp_protocolVersion| { &mut m.vm },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "db",
                    |m: &rsp_protocolVersion| { &m.db },
                    |m: &mut rsp_protocolVersion| { &mut m.db },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "miner",
                    |m: &rsp_protocolVersion| { &m.miner },
                    |m: &mut rsp_protocolVersion| { &mut m.miner },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txpool",
                    |m: &rsp_protocolVersion| { &m.txpool },
                    |m: &mut rsp_protocolVersion| { &mut m.txpool },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_protocolVersion>(
                    "rsp_protocolVersion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_protocolVersion {
        static mut instance: ::protobuf::lazy::Lazy<rsp_protocolVersion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_protocolVersion,
        };
        unsafe {
            instance.get(rsp_protocolVersion::new)
        }
    }
}

impl ::protobuf::Clear for rsp_protocolVersion {
    fn clear(&mut self) {
        self.clear_kernel();
        self.clear_net();
        self.clear_api();
        self.clear_vm();
        self.clear_db();
        self.clear_miner();
        self.clear_txpool();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_protocolVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_protocolVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_minerAddress {
    // message fields
    pub minerAddr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_minerAddress {
    pub fn new() -> rsp_minerAddress {
        ::std::default::Default::default()
    }

    // bytes minerAddr = 1;

    pub fn clear_minerAddr(&mut self) {
        self.minerAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_minerAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.minerAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minerAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.minerAddr
    }

    // Take field
    pub fn take_minerAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.minerAddr, ::std::vec::Vec::new())
    }

    pub fn get_minerAddr(&self) -> &[u8] {
        &self.minerAddr
    }
}

impl ::protobuf::Message for rsp_minerAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.minerAddr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.minerAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.minerAddr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.minerAddr.is_empty() {
            os.write_bytes(1, &self.minerAddr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_minerAddress {
        rsp_minerAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "minerAddr",
                    |m: &rsp_minerAddress| { &m.minerAddr },
                    |m: &mut rsp_minerAddress| { &mut m.minerAddr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_minerAddress>(
                    "rsp_minerAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_minerAddress {
        static mut instance: ::protobuf::lazy::Lazy<rsp_minerAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_minerAddress,
        };
        unsafe {
            instance.get(rsp_minerAddress::new)
        }
    }
}

impl ::protobuf::Clear for rsp_minerAddress {
    fn clear(&mut self) {
        self.clear_minerAddr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_minerAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_minerAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockByNumber {
    // message fields
    pub blockNumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockByNumber {
    pub fn new() -> req_getBlockByNumber {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }
}

impl ::protobuf::Message for req_getBlockByNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockByNumber {
        req_getBlockByNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &req_getBlockByNumber| { &m.blockNumber },
                    |m: &mut req_getBlockByNumber| { &mut m.blockNumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockByNumber>(
                    "req_getBlockByNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockByNumber {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockByNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockByNumber,
        };
        unsafe {
            instance.get(req_getBlockByNumber::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockByNumber {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockByNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockByNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlock {
    // message fields
    pub blockNumber: u64,
    pub timestamp: u64,
    pub nrgConsumed: u64,
    pub nrgLimit: u64,
    pub parentHash: ::std::vec::Vec<u8>,
    pub minerAddress: ::std::vec::Vec<u8>,
    pub stateRoot: ::std::vec::Vec<u8>,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub receiptTrieRoot: ::std::vec::Vec<u8>,
    pub logsBloom: ::std::vec::Vec<u8>,
    pub difficulty: ::std::vec::Vec<u8>,
    pub totalDifficulty: ::std::vec::Vec<u8>,
    pub extraData: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub solution: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub size: u32,
    pub txHash: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlock {
    pub fn new() -> rsp_getBlock {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 nrgConsumed = 3;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgLimit = 4;

    pub fn clear_nrgLimit(&mut self) {
        self.nrgLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgLimit(&mut self, v: u64) {
        self.nrgLimit = v;
    }

    pub fn get_nrgLimit(&self) -> u64 {
        self.nrgLimit
    }

    // bytes parentHash = 5;

    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }

    // bytes minerAddress = 6;

    pub fn clear_minerAddress(&mut self) {
        self.minerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_minerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.minerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.minerAddress
    }

    // Take field
    pub fn take_minerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.minerAddress, ::std::vec::Vec::new())
    }

    pub fn get_minerAddress(&self) -> &[u8] {
        &self.minerAddress
    }

    // bytes stateRoot = 7;

    pub fn clear_stateRoot(&mut self) {
        self.stateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_stateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.stateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stateRoot
    }

    // Take field
    pub fn take_stateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stateRoot, ::std::vec::Vec::new())
    }

    pub fn get_stateRoot(&self) -> &[u8] {
        &self.stateRoot
    }

    // bytes txTrieRoot = 8;

    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }

    // bytes receiptTrieRoot = 9;

    pub fn clear_receiptTrieRoot(&mut self) {
        self.receiptTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiptTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiptTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiptTrieRoot
    }

    // Take field
    pub fn take_receiptTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiptTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_receiptTrieRoot(&self) -> &[u8] {
        &self.receiptTrieRoot
    }

    // bytes logsBloom = 10;

    pub fn clear_logsBloom(&mut self) {
        self.logsBloom.clear();
    }

    // Param is passed by value, moved
    pub fn set_logsBloom(&mut self, v: ::std::vec::Vec<u8>) {
        self.logsBloom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logsBloom(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logsBloom
    }

    // Take field
    pub fn take_logsBloom(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logsBloom, ::std::vec::Vec::new())
    }

    pub fn get_logsBloom(&self) -> &[u8] {
        &self.logsBloom
    }

    // bytes difficulty = 11;

    pub fn clear_difficulty(&mut self) {
        self.difficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.difficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_difficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.difficulty
    }

    // Take field
    pub fn take_difficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.difficulty, ::std::vec::Vec::new())
    }

    pub fn get_difficulty(&self) -> &[u8] {
        &self.difficulty
    }

    // bytes totalDifficulty = 12;

    pub fn clear_totalDifficulty(&mut self) {
        self.totalDifficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalDifficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.totalDifficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalDifficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.totalDifficulty
    }

    // Take field
    pub fn take_totalDifficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.totalDifficulty, ::std::vec::Vec::new())
    }

    pub fn get_totalDifficulty(&self) -> &[u8] {
        &self.totalDifficulty
    }

    // bytes extraData = 13;

    pub fn clear_extraData(&mut self) {
        self.extraData.clear();
    }

    // Param is passed by value, moved
    pub fn set_extraData(&mut self, v: ::std::vec::Vec<u8>) {
        self.extraData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extraData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extraData
    }

    // Take field
    pub fn take_extraData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extraData, ::std::vec::Vec::new())
    }

    pub fn get_extraData(&self) -> &[u8] {
        &self.extraData
    }

    // bytes nonce = 14;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes solution = 15;

    pub fn clear_solution(&mut self) {
        self.solution.clear();
    }

    // Param is passed by value, moved
    pub fn set_solution(&mut self, v: ::std::vec::Vec<u8>) {
        self.solution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solution(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.solution
    }

    // Take field
    pub fn take_solution(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.solution, ::std::vec::Vec::new())
    }

    pub fn get_solution(&self) -> &[u8] {
        &self.solution
    }

    // bytes hash = 16;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // uint32 size = 17;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    pub fn get_size(&self) -> u32 {
        self.size
    }

    // repeated bytes txHash = 18;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    pub fn mut_txHash(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.txHash, ::protobuf::RepeatedField::new())
    }

    pub fn get_txHash(&self) -> &[::std::vec::Vec<u8>] {
        &self.txHash
    }
}

impl ::protobuf::Message for rsp_getBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.minerAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stateRoot)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiptTrieRoot)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logsBloom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.difficulty)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.totalDifficulty)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extraData)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.solution)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                18 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nrgLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.parentHash);
        }
        if !self.minerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.minerAddress);
        }
        if !self.stateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.stateRoot);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.txTrieRoot);
        }
        if !self.receiptTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.receiptTrieRoot);
        }
        if !self.logsBloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.logsBloom);
        }
        if !self.difficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.difficulty);
        }
        if !self.totalDifficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.totalDifficulty);
        }
        if !self.extraData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.extraData);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.nonce);
        }
        if !self.solution.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.solution);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.hash);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(17, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.txHash {
            my_size += ::protobuf::rt::bytes_size(18, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(3, self.nrgConsumed)?;
        }
        if self.nrgLimit != 0 {
            os.write_uint64(4, self.nrgLimit)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(5, &self.parentHash)?;
        }
        if !self.minerAddress.is_empty() {
            os.write_bytes(6, &self.minerAddress)?;
        }
        if !self.stateRoot.is_empty() {
            os.write_bytes(7, &self.stateRoot)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(8, &self.txTrieRoot)?;
        }
        if !self.receiptTrieRoot.is_empty() {
            os.write_bytes(9, &self.receiptTrieRoot)?;
        }
        if !self.logsBloom.is_empty() {
            os.write_bytes(10, &self.logsBloom)?;
        }
        if !self.difficulty.is_empty() {
            os.write_bytes(11, &self.difficulty)?;
        }
        if !self.totalDifficulty.is_empty() {
            os.write_bytes(12, &self.totalDifficulty)?;
        }
        if !self.extraData.is_empty() {
            os.write_bytes(13, &self.extraData)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(14, &self.nonce)?;
        }
        if !self.solution.is_empty() {
            os.write_bytes(15, &self.solution)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(16, &self.hash)?;
        }
        if self.size != 0 {
            os.write_uint32(17, self.size)?;
        }
        for v in &self.txHash {
            os.write_bytes(18, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlock {
        rsp_getBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &rsp_getBlock| { &m.blockNumber },
                    |m: &mut rsp_getBlock| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &rsp_getBlock| { &m.timestamp },
                    |m: &mut rsp_getBlock| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &rsp_getBlock| { &m.nrgConsumed },
                    |m: &mut rsp_getBlock| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgLimit",
                    |m: &rsp_getBlock| { &m.nrgLimit },
                    |m: &mut rsp_getBlock| { &mut m.nrgLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parentHash",
                    |m: &rsp_getBlock| { &m.parentHash },
                    |m: &mut rsp_getBlock| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "minerAddress",
                    |m: &rsp_getBlock| { &m.minerAddress },
                    |m: &mut rsp_getBlock| { &mut m.minerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stateRoot",
                    |m: &rsp_getBlock| { &m.stateRoot },
                    |m: &mut rsp_getBlock| { &mut m.stateRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txTrieRoot",
                    |m: &rsp_getBlock| { &m.txTrieRoot },
                    |m: &mut rsp_getBlock| { &mut m.txTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiptTrieRoot",
                    |m: &rsp_getBlock| { &m.receiptTrieRoot },
                    |m: &mut rsp_getBlock| { &mut m.receiptTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "logsBloom",
                    |m: &rsp_getBlock| { &m.logsBloom },
                    |m: &mut rsp_getBlock| { &mut m.logsBloom },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "difficulty",
                    |m: &rsp_getBlock| { &m.difficulty },
                    |m: &mut rsp_getBlock| { &mut m.difficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "totalDifficulty",
                    |m: &rsp_getBlock| { &m.totalDifficulty },
                    |m: &mut rsp_getBlock| { &mut m.totalDifficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extraData",
                    |m: &rsp_getBlock| { &m.extraData },
                    |m: &mut rsp_getBlock| { &mut m.extraData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &rsp_getBlock| { &m.nonce },
                    |m: &mut rsp_getBlock| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "solution",
                    |m: &rsp_getBlock| { &m.solution },
                    |m: &mut rsp_getBlock| { &mut m.solution },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &rsp_getBlock| { &m.hash },
                    |m: &mut rsp_getBlock| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &rsp_getBlock| { &m.size },
                    |m: &mut rsp_getBlock| { &mut m.size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &rsp_getBlock| { &m.txHash },
                    |m: &mut rsp_getBlock| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlock>(
                    "rsp_getBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlock {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlock,
        };
        unsafe {
            instance.get(rsp_getBlock::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlock {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_timestamp();
        self.clear_nrgConsumed();
        self.clear_nrgLimit();
        self.clear_parentHash();
        self.clear_minerAddress();
        self.clear_stateRoot();
        self.clear_txTrieRoot();
        self.clear_receiptTrieRoot();
        self.clear_logsBloom();
        self.clear_difficulty();
        self.clear_totalDifficulty();
        self.clear_extraData();
        self.clear_nonce();
        self.clear_solution();
        self.clear_hash();
        self.clear_size();
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockHeaderByNumber {
    // message fields
    pub blockNumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockHeaderByNumber {
    pub fn new() -> req_getBlockHeaderByNumber {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }
}

impl ::protobuf::Message for req_getBlockHeaderByNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockHeaderByNumber {
        req_getBlockHeaderByNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &req_getBlockHeaderByNumber| { &m.blockNumber },
                    |m: &mut req_getBlockHeaderByNumber| { &mut m.blockNumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockHeaderByNumber>(
                    "req_getBlockHeaderByNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockHeaderByNumber {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockHeaderByNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockHeaderByNumber,
        };
        unsafe {
            instance.get(req_getBlockHeaderByNumber::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockHeaderByNumber {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockHeaderByNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockHeaderByNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockHeader {
    // message fields
    pub blockNumber: u64,
    pub timestamp: u64,
    pub nrgConsumed: u64,
    pub nrgLimit: u64,
    pub parentHash: ::std::vec::Vec<u8>,
    pub minerAddress: ::std::vec::Vec<u8>,
    pub stateRoot: ::std::vec::Vec<u8>,
    pub txTrieRoot: ::std::vec::Vec<u8>,
    pub receiptTrieRoot: ::std::vec::Vec<u8>,
    pub logsBloom: ::std::vec::Vec<u8>,
    pub difficulty: ::std::vec::Vec<u8>,
    pub extraData: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub solution: ::std::vec::Vec<u8>,
    pub hash: ::std::vec::Vec<u8>,
    pub size: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockHeader {
    pub fn new() -> rsp_getBlockHeader {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint64 timestamp = 2;

    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u64) {
        self.timestamp = v;
    }

    pub fn get_timestamp(&self) -> u64 {
        self.timestamp
    }

    // uint64 nrgConsumed = 3;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 nrgLimit = 4;

    pub fn clear_nrgLimit(&mut self) {
        self.nrgLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgLimit(&mut self, v: u64) {
        self.nrgLimit = v;
    }

    pub fn get_nrgLimit(&self) -> u64 {
        self.nrgLimit
    }

    // bytes parentHash = 5;

    pub fn clear_parentHash(&mut self) {
        self.parentHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_parentHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.parentHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parentHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parentHash
    }

    // Take field
    pub fn take_parentHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parentHash, ::std::vec::Vec::new())
    }

    pub fn get_parentHash(&self) -> &[u8] {
        &self.parentHash
    }

    // bytes minerAddress = 6;

    pub fn clear_minerAddress(&mut self) {
        self.minerAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_minerAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.minerAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minerAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.minerAddress
    }

    // Take field
    pub fn take_minerAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.minerAddress, ::std::vec::Vec::new())
    }

    pub fn get_minerAddress(&self) -> &[u8] {
        &self.minerAddress
    }

    // bytes stateRoot = 7;

    pub fn clear_stateRoot(&mut self) {
        self.stateRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_stateRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.stateRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stateRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.stateRoot
    }

    // Take field
    pub fn take_stateRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.stateRoot, ::std::vec::Vec::new())
    }

    pub fn get_stateRoot(&self) -> &[u8] {
        &self.stateRoot
    }

    // bytes txTrieRoot = 8;

    pub fn clear_txTrieRoot(&mut self) {
        self.txTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_txTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.txTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txTrieRoot
    }

    // Take field
    pub fn take_txTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_txTrieRoot(&self) -> &[u8] {
        &self.txTrieRoot
    }

    // bytes receiptTrieRoot = 9;

    pub fn clear_receiptTrieRoot(&mut self) {
        self.receiptTrieRoot.clear();
    }

    // Param is passed by value, moved
    pub fn set_receiptTrieRoot(&mut self, v: ::std::vec::Vec<u8>) {
        self.receiptTrieRoot = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receiptTrieRoot(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.receiptTrieRoot
    }

    // Take field
    pub fn take_receiptTrieRoot(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.receiptTrieRoot, ::std::vec::Vec::new())
    }

    pub fn get_receiptTrieRoot(&self) -> &[u8] {
        &self.receiptTrieRoot
    }

    // bytes logsBloom = 10;

    pub fn clear_logsBloom(&mut self) {
        self.logsBloom.clear();
    }

    // Param is passed by value, moved
    pub fn set_logsBloom(&mut self, v: ::std::vec::Vec<u8>) {
        self.logsBloom = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logsBloom(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.logsBloom
    }

    // Take field
    pub fn take_logsBloom(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.logsBloom, ::std::vec::Vec::new())
    }

    pub fn get_logsBloom(&self) -> &[u8] {
        &self.logsBloom
    }

    // bytes difficulty = 11;

    pub fn clear_difficulty(&mut self) {
        self.difficulty.clear();
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: ::std::vec::Vec<u8>) {
        self.difficulty = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_difficulty(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.difficulty
    }

    // Take field
    pub fn take_difficulty(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.difficulty, ::std::vec::Vec::new())
    }

    pub fn get_difficulty(&self) -> &[u8] {
        &self.difficulty
    }

    // bytes extraData = 12;

    pub fn clear_extraData(&mut self) {
        self.extraData.clear();
    }

    // Param is passed by value, moved
    pub fn set_extraData(&mut self, v: ::std::vec::Vec<u8>) {
        self.extraData = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extraData(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.extraData
    }

    // Take field
    pub fn take_extraData(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.extraData, ::std::vec::Vec::new())
    }

    pub fn get_extraData(&self) -> &[u8] {
        &self.extraData
    }

    // bytes nonce = 13;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes solution = 14;

    pub fn clear_solution(&mut self) {
        self.solution.clear();
    }

    // Param is passed by value, moved
    pub fn set_solution(&mut self, v: ::std::vec::Vec<u8>) {
        self.solution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solution(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.solution
    }

    // Take field
    pub fn take_solution(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.solution, ::std::vec::Vec::new())
    }

    pub fn get_solution(&self) -> &[u8] {
        &self.solution
    }

    // bytes hash = 15;

    pub fn clear_hash(&mut self) {
        self.hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hash
    }

    // Take field
    pub fn take_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hash, ::std::vec::Vec::new())
    }

    pub fn get_hash(&self) -> &[u8] {
        &self.hash
    }

    // uint32 size = 16;

    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = v;
    }

    pub fn get_size(&self) -> u32 {
        self.size
    }
}

impl ::protobuf::Message for rsp_getBlockHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timestamp = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgLimit = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parentHash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.minerAddress)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.stateRoot)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txTrieRoot)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.receiptTrieRoot)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.logsBloom)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.difficulty)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.extraData)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.solution)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hash)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(2, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgLimit != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nrgLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.parentHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.parentHash);
        }
        if !self.minerAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.minerAddress);
        }
        if !self.stateRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.stateRoot);
        }
        if !self.txTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.txTrieRoot);
        }
        if !self.receiptTrieRoot.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.receiptTrieRoot);
        }
        if !self.logsBloom.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.logsBloom);
        }
        if !self.difficulty.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.difficulty);
        }
        if !self.extraData.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.extraData);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.nonce);
        }
        if !self.solution.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.solution);
        }
        if !self.hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.hash);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(16, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if self.timestamp != 0 {
            os.write_uint64(2, self.timestamp)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(3, self.nrgConsumed)?;
        }
        if self.nrgLimit != 0 {
            os.write_uint64(4, self.nrgLimit)?;
        }
        if !self.parentHash.is_empty() {
            os.write_bytes(5, &self.parentHash)?;
        }
        if !self.minerAddress.is_empty() {
            os.write_bytes(6, &self.minerAddress)?;
        }
        if !self.stateRoot.is_empty() {
            os.write_bytes(7, &self.stateRoot)?;
        }
        if !self.txTrieRoot.is_empty() {
            os.write_bytes(8, &self.txTrieRoot)?;
        }
        if !self.receiptTrieRoot.is_empty() {
            os.write_bytes(9, &self.receiptTrieRoot)?;
        }
        if !self.logsBloom.is_empty() {
            os.write_bytes(10, &self.logsBloom)?;
        }
        if !self.difficulty.is_empty() {
            os.write_bytes(11, &self.difficulty)?;
        }
        if !self.extraData.is_empty() {
            os.write_bytes(12, &self.extraData)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(13, &self.nonce)?;
        }
        if !self.solution.is_empty() {
            os.write_bytes(14, &self.solution)?;
        }
        if !self.hash.is_empty() {
            os.write_bytes(15, &self.hash)?;
        }
        if self.size != 0 {
            os.write_uint32(16, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockHeader {
        rsp_getBlockHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &rsp_getBlockHeader| { &m.blockNumber },
                    |m: &mut rsp_getBlockHeader| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timestamp",
                    |m: &rsp_getBlockHeader| { &m.timestamp },
                    |m: &mut rsp_getBlockHeader| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &rsp_getBlockHeader| { &m.nrgConsumed },
                    |m: &mut rsp_getBlockHeader| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgLimit",
                    |m: &rsp_getBlockHeader| { &m.nrgLimit },
                    |m: &mut rsp_getBlockHeader| { &mut m.nrgLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "parentHash",
                    |m: &rsp_getBlockHeader| { &m.parentHash },
                    |m: &mut rsp_getBlockHeader| { &mut m.parentHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "minerAddress",
                    |m: &rsp_getBlockHeader| { &m.minerAddress },
                    |m: &mut rsp_getBlockHeader| { &mut m.minerAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "stateRoot",
                    |m: &rsp_getBlockHeader| { &m.stateRoot },
                    |m: &mut rsp_getBlockHeader| { &mut m.stateRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txTrieRoot",
                    |m: &rsp_getBlockHeader| { &m.txTrieRoot },
                    |m: &mut rsp_getBlockHeader| { &mut m.txTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "receiptTrieRoot",
                    |m: &rsp_getBlockHeader| { &m.receiptTrieRoot },
                    |m: &mut rsp_getBlockHeader| { &mut m.receiptTrieRoot },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "logsBloom",
                    |m: &rsp_getBlockHeader| { &m.logsBloom },
                    |m: &mut rsp_getBlockHeader| { &mut m.logsBloom },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "difficulty",
                    |m: &rsp_getBlockHeader| { &m.difficulty },
                    |m: &mut rsp_getBlockHeader| { &mut m.difficulty },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "extraData",
                    |m: &rsp_getBlockHeader| { &m.extraData },
                    |m: &mut rsp_getBlockHeader| { &mut m.extraData },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &rsp_getBlockHeader| { &m.nonce },
                    |m: &mut rsp_getBlockHeader| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "solution",
                    |m: &rsp_getBlockHeader| { &m.solution },
                    |m: &mut rsp_getBlockHeader| { &mut m.solution },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hash",
                    |m: &rsp_getBlockHeader| { &m.hash },
                    |m: &mut rsp_getBlockHeader| { &mut m.hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "size",
                    |m: &rsp_getBlockHeader| { &m.size },
                    |m: &mut rsp_getBlockHeader| { &mut m.size },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockHeader>(
                    "rsp_getBlockHeader",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockHeader {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockHeader> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockHeader,
        };
        unsafe {
            instance.get(rsp_getBlockHeader::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockHeader {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_timestamp();
        self.clear_nrgConsumed();
        self.clear_nrgLimit();
        self.clear_parentHash();
        self.clear_minerAddress();
        self.clear_stateRoot();
        self.clear_txTrieRoot();
        self.clear_receiptTrieRoot();
        self.clear_logsBloom();
        self.clear_difficulty();
        self.clear_extraData();
        self.clear_nonce();
        self.clear_solution();
        self.clear_hash();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_sendTransaction {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub nrg: u64,
    pub nrgPrice: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_sendTransaction {
    pub fn new() -> req_sendTransaction {
        ::std::default::Default::default()
    }

    // bytes from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 2;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes nonce = 5;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // uint64 nrg = 6;

    pub fn clear_nrg(&mut self) {
        self.nrg = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrg(&mut self, v: u64) {
        self.nrg = v;
    }

    pub fn get_nrg(&self) -> u64 {
        self.nrg
    }

    // uint64 nrgPrice = 7;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }
}

impl ::protobuf::Message for req_sendTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrg = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.nonce);
        }
        if self.nrg != 0 {
            my_size += ::protobuf::rt::value_size(6, self.nrg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(7, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(5, &self.nonce)?;
        }
        if self.nrg != 0 {
            os.write_uint64(6, self.nrg)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(7, self.nrgPrice)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_sendTransaction {
        req_sendTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &req_sendTransaction| { &m.from },
                    |m: &mut req_sendTransaction| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &req_sendTransaction| { &m.to },
                    |m: &mut req_sendTransaction| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &req_sendTransaction| { &m.value },
                    |m: &mut req_sendTransaction| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &req_sendTransaction| { &m.data },
                    |m: &mut req_sendTransaction| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &req_sendTransaction| { &m.nonce },
                    |m: &mut req_sendTransaction| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrg",
                    |m: &req_sendTransaction| { &m.nrg },
                    |m: &mut req_sendTransaction| { &mut m.nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &req_sendTransaction| { &m.nrgPrice },
                    |m: &mut req_sendTransaction| { &mut m.nrgPrice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_sendTransaction>(
                    "req_sendTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_sendTransaction {
        static mut instance: ::protobuf::lazy::Lazy<req_sendTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_sendTransaction,
        };
        unsafe {
            instance.get(req_sendTransaction::new)
        }
    }
}

impl ::protobuf::Clear for req_sendTransaction {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_to();
        self.clear_value();
        self.clear_data();
        self.clear_nonce();
        self.clear_nrg();
        self.clear_nrgPrice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_sendTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_sendTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_sendTransaction {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_sendTransaction {
    pub fn new() -> rsp_sendTransaction {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }
}

impl ::protobuf::Message for rsp_sendTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_sendTransaction {
        rsp_sendTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &rsp_sendTransaction| { &m.txHash },
                    |m: &mut rsp_sendTransaction| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_sendTransaction>(
                    "rsp_sendTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_sendTransaction {
        static mut instance: ::protobuf::lazy::Lazy<rsp_sendTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_sendTransaction,
        };
        unsafe {
            instance.get(rsp_sendTransaction::new)
        }
    }
}

impl ::protobuf::Clear for rsp_sendTransaction {
    fn clear(&mut self) {
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_sendTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_sendTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionByHash {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionByHash {
    pub fn new() -> req_getTransactionByHash {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }
}

impl ::protobuf::Message for req_getTransactionByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionByHash {
        req_getTransactionByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &req_getTransactionByHash| { &m.txHash },
                    |m: &mut req_getTransactionByHash| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionByHash>(
                    "req_getTransactionByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionByHash,
        };
        unsafe {
            instance.get(req_getTransactionByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionByHash {
    fn clear(&mut self) {
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getTransaction {
    // message fields
    pub txIndex: u32,
    pub blocknumber: u64,
    pub timeStamp: u64,
    pub nrgConsume: u64,
    pub nrgPrice: u64,
    pub blockhash: ::std::vec::Vec<u8>,
    pub from: ::std::vec::Vec<u8>,
    pub txHash: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub nonce: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getTransaction {
    pub fn new() -> rsp_getTransaction {
        ::std::default::Default::default()
    }

    // uint32 txIndex = 1;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }

    // uint64 blocknumber = 2;

    pub fn clear_blocknumber(&mut self) {
        self.blocknumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocknumber(&mut self, v: u64) {
        self.blocknumber = v;
    }

    pub fn get_blocknumber(&self) -> u64 {
        self.blocknumber
    }

    // uint64 timeStamp = 3;

    pub fn clear_timeStamp(&mut self) {
        self.timeStamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timeStamp(&mut self, v: u64) {
        self.timeStamp = v;
    }

    pub fn get_timeStamp(&self) -> u64 {
        self.timeStamp
    }

    // uint64 nrgConsume = 4;

    pub fn clear_nrgConsume(&mut self) {
        self.nrgConsume = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsume(&mut self, v: u64) {
        self.nrgConsume = v;
    }

    pub fn get_nrgConsume(&self) -> u64 {
        self.nrgConsume
    }

    // uint64 nrgPrice = 5;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }

    // bytes blockhash = 6;

    pub fn clear_blockhash(&mut self) {
        self.blockhash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockhash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockhash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockhash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockhash
    }

    // Take field
    pub fn take_blockhash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockhash, ::std::vec::Vec::new())
    }

    pub fn get_blockhash(&self) -> &[u8] {
        &self.blockhash
    }

    // bytes from = 7;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes txHash = 8;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }

    // bytes data = 9;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes nonce = 10;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes to = 11;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes value = 12;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
}

impl ::protobuf::Message for rsp_getTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocknumber = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.timeStamp = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsume = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockhash)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(1, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocknumber != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blocknumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timeStamp != 0 {
            my_size += ::protobuf::rt::value_size(3, self.timeStamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsume != 0 {
            my_size += ::protobuf::rt::value_size(4, self.nrgConsume, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blockhash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.blockhash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.from);
        }
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.txHash);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.data);
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(10, &self.nonce);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.to);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.txIndex != 0 {
            os.write_uint32(1, self.txIndex)?;
        }
        if self.blocknumber != 0 {
            os.write_uint64(2, self.blocknumber)?;
        }
        if self.timeStamp != 0 {
            os.write_uint64(3, self.timeStamp)?;
        }
        if self.nrgConsume != 0 {
            os.write_uint64(4, self.nrgConsume)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(5, self.nrgPrice)?;
        }
        if !self.blockhash.is_empty() {
            os.write_bytes(6, &self.blockhash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(7, &self.from)?;
        }
        if !self.txHash.is_empty() {
            os.write_bytes(8, &self.txHash)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(9, &self.data)?;
        }
        if !self.nonce.is_empty() {
            os.write_bytes(10, &self.nonce)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(11, &self.to)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(12, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getTransaction {
        rsp_getTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &rsp_getTransaction| { &m.txIndex },
                    |m: &mut rsp_getTransaction| { &mut m.txIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocknumber",
                    |m: &rsp_getTransaction| { &m.blocknumber },
                    |m: &mut rsp_getTransaction| { &mut m.blocknumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "timeStamp",
                    |m: &rsp_getTransaction| { &m.timeStamp },
                    |m: &mut rsp_getTransaction| { &mut m.timeStamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsume",
                    |m: &rsp_getTransaction| { &m.nrgConsume },
                    |m: &mut rsp_getTransaction| { &mut m.nrgConsume },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &rsp_getTransaction| { &m.nrgPrice },
                    |m: &mut rsp_getTransaction| { &mut m.nrgPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockhash",
                    |m: &rsp_getTransaction| { &m.blockhash },
                    |m: &mut rsp_getTransaction| { &mut m.blockhash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &rsp_getTransaction| { &m.from },
                    |m: &mut rsp_getTransaction| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &rsp_getTransaction| { &m.txHash },
                    |m: &mut rsp_getTransaction| { &mut m.txHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &rsp_getTransaction| { &m.data },
                    |m: &mut rsp_getTransaction| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &rsp_getTransaction| { &m.nonce },
                    |m: &mut rsp_getTransaction| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &rsp_getTransaction| { &m.to },
                    |m: &mut rsp_getTransaction| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &rsp_getTransaction| { &m.value },
                    |m: &mut rsp_getTransaction| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getTransaction>(
                    "rsp_getTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getTransaction {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getTransaction,
        };
        unsafe {
            instance.get(rsp_getTransaction::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getTransaction {
    fn clear(&mut self) {
        self.clear_txIndex();
        self.clear_blocknumber();
        self.clear_timeStamp();
        self.clear_nrgConsume();
        self.clear_nrgPrice();
        self.clear_blockhash();
        self.clear_from();
        self.clear_txHash();
        self.clear_data();
        self.clear_nonce();
        self.clear_to();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_unlockAccount {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub password: ::std::string::String,
    pub duration: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_unlockAccount {
    pub fn new() -> req_unlockAccount {
        ::std::default::Default::default()
    }

    // bytes account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    pub fn get_account(&self) -> &[u8] {
        &self.account
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }

    // uint32 duration = 3;

    pub fn clear_duration(&mut self) {
        self.duration = 0;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = v;
    }

    pub fn get_duration(&self) -> u32 {
        self.duration
    }
}

impl ::protobuf::Message for req_unlockAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.duration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::value_size(3, self.duration, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if self.duration != 0 {
            os.write_uint32(3, self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_unlockAccount {
        req_unlockAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account",
                    |m: &req_unlockAccount| { &m.account },
                    |m: &mut req_unlockAccount| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &req_unlockAccount| { &m.password },
                    |m: &mut req_unlockAccount| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "duration",
                    |m: &req_unlockAccount| { &m.duration },
                    |m: &mut req_unlockAccount| { &mut m.duration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_unlockAccount>(
                    "req_unlockAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_unlockAccount {
        static mut instance: ::protobuf::lazy::Lazy<req_unlockAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_unlockAccount,
        };
        unsafe {
            instance.get(req_unlockAccount::new)
        }
    }
}

impl ::protobuf::Clear for req_unlockAccount {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_password();
        self.clear_duration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_unlockAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_unlockAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_accounts {
    // message fields
    pub accout: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_accounts {
    pub fn new() -> rsp_accounts {
        ::std::default::Default::default()
    }

    // repeated bytes accout = 1;

    pub fn clear_accout(&mut self) {
        self.accout.clear();
    }

    // Param is passed by value, moved
    pub fn set_accout(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.accout = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accout(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.accout
    }

    // Take field
    pub fn take_accout(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.accout, ::protobuf::RepeatedField::new())
    }

    pub fn get_accout(&self) -> &[::std::vec::Vec<u8>] {
        &self.accout
    }
}

impl ::protobuf::Message for rsp_accounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.accout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accout {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accout {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_accounts {
        rsp_accounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "accout",
                    |m: &rsp_accounts| { &m.accout },
                    |m: &mut rsp_accounts| { &mut m.accout },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_accounts>(
                    "rsp_accounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_accounts {
        static mut instance: ::protobuf::lazy::Lazy<rsp_accounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_accounts,
        };
        unsafe {
            instance.get(rsp_accounts::new)
        }
    }
}

impl ::protobuf::Clear for rsp_accounts {
    fn clear(&mut self) {
        self.clear_accout();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_accounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_accounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_compile {
    // message fields
    pub code: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_compile {
    pub fn new() -> req_compile {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    pub fn get_code(&self) -> &str {
        &self.code
    }
}

impl ::protobuf::Message for req_compile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_compile {
        req_compile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    |m: &req_compile| { &m.code },
                    |m: &mut req_compile| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_compile>(
                    "req_compile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_compile {
        static mut instance: ::protobuf::lazy::Lazy<req_compile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_compile,
        };
        unsafe {
            instance.get(req_compile::new)
        }
    }
}

impl ::protobuf::Clear for req_compile {
    fn clear(&mut self) {
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_compile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_compile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_compile {
    // message fields
    pub constracts: ::std::collections::HashMap<::std::string::String, t_Contract>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_compile {
    pub fn new() -> rsp_compile {
        ::std::default::Default::default()
    }

    // repeated .bp_api.rsp_compile.ConstractsEntry constracts = 1;

    pub fn clear_constracts(&mut self) {
        self.constracts.clear();
    }

    // Param is passed by value, moved
    pub fn set_constracts(&mut self, v: ::std::collections::HashMap<::std::string::String, t_Contract>) {
        self.constracts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_constracts(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, t_Contract> {
        &mut self.constracts
    }

    // Take field
    pub fn take_constracts(&mut self) -> ::std::collections::HashMap<::std::string::String, t_Contract> {
        ::std::mem::replace(&mut self.constracts, ::std::collections::HashMap::new())
    }

    pub fn get_constracts(&self) -> &::std::collections::HashMap<::std::string::String, t_Contract> {
        &self.constracts
    }
}

impl ::protobuf::Message for rsp_compile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<t_Contract>>(wire_type, is, &mut self.constracts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<t_Contract>>(1, &self.constracts);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<t_Contract>>(1, &self.constracts, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_compile {
        rsp_compile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<t_Contract>>(
                    "constracts",
                    |m: &rsp_compile| { &m.constracts },
                    |m: &mut rsp_compile| { &mut m.constracts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_compile>(
                    "rsp_compile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_compile {
        static mut instance: ::protobuf::lazy::Lazy<rsp_compile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_compile,
        };
        unsafe {
            instance.get(rsp_compile::new)
        }
    }
}

impl ::protobuf::Clear for rsp_compile {
    fn clear(&mut self) {
        self.clear_constracts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_compile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_compile {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getCode {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub blocknumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getCode {
    pub fn new() -> req_getCode {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // uint64 blocknumber = 2;

    pub fn clear_blocknumber(&mut self) {
        self.blocknumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocknumber(&mut self, v: u64) {
        self.blocknumber = v;
    }

    pub fn get_blocknumber(&self) -> u64 {
        self.blocknumber
    }
}

impl ::protobuf::Message for req_getCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocknumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.blocknumber != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blocknumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.blocknumber != 0 {
            os.write_uint64(2, self.blocknumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getCode {
        req_getCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &req_getCode| { &m.address },
                    |m: &mut req_getCode| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocknumber",
                    |m: &req_getCode| { &m.blocknumber },
                    |m: &mut req_getCode| { &mut m.blocknumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getCode>(
                    "req_getCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getCode {
        static mut instance: ::protobuf::lazy::Lazy<req_getCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getCode,
        };
        unsafe {
            instance.get(req_getCode::new)
        }
    }
}

impl ::protobuf::Clear for req_getCode {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_blocknumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getCode {
    // message fields
    pub code: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getCode {
    pub fn new() -> rsp_getCode {
        ::std::default::Default::default()
    }

    // bytes code = 1;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }

    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
}

impl ::protobuf::Message for rsp_getCode {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_bytes(1, &self.code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getCode {
        rsp_getCode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code",
                    |m: &rsp_getCode| { &m.code },
                    |m: &mut rsp_getCode| { &mut m.code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getCode>(
                    "rsp_getCode",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getCode {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getCode> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getCode,
        };
        unsafe {
            instance.get(rsp_getCode::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getCode {
    fn clear(&mut self) {
        self.clear_code();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getCode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_contractDeploy {
    // message fields
    pub nrgLimit: u64,
    pub nrgPrice: u64,
    pub from: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_contractDeploy {
    pub fn new() -> req_contractDeploy {
        ::std::default::Default::default()
    }

    // uint64 nrgLimit = 1;

    pub fn clear_nrgLimit(&mut self) {
        self.nrgLimit = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgLimit(&mut self, v: u64) {
        self.nrgLimit = v;
    }

    pub fn get_nrgLimit(&self) -> u64 {
        self.nrgLimit
    }

    // uint64 nrgPrice = 2;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }

    // bytes from = 3;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes value = 5;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
}

impl ::protobuf::Message for req_contractDeploy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgLimit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nrgLimit != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nrgLimit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.from);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.nrgLimit != 0 {
            os.write_uint64(1, self.nrgLimit)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(2, self.nrgPrice)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(3, &self.from)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(5, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_contractDeploy {
        req_contractDeploy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgLimit",
                    |m: &req_contractDeploy| { &m.nrgLimit },
                    |m: &mut req_contractDeploy| { &mut m.nrgLimit },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &req_contractDeploy| { &m.nrgPrice },
                    |m: &mut req_contractDeploy| { &mut m.nrgPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &req_contractDeploy| { &m.from },
                    |m: &mut req_contractDeploy| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &req_contractDeploy| { &m.data },
                    |m: &mut req_contractDeploy| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &req_contractDeploy| { &m.value },
                    |m: &mut req_contractDeploy| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_contractDeploy>(
                    "req_contractDeploy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_contractDeploy {
        static mut instance: ::protobuf::lazy::Lazy<req_contractDeploy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_contractDeploy,
        };
        unsafe {
            instance.get(req_contractDeploy::new)
        }
    }
}

impl ::protobuf::Clear for req_contractDeploy {
    fn clear(&mut self) {
        self.clear_nrgLimit();
        self.clear_nrgPrice();
        self.clear_from();
        self.clear_data();
        self.clear_value();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_contractDeploy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_contractDeploy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_contractDeploy {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    pub contractAddress: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_contractDeploy {
    pub fn new() -> rsp_contractDeploy {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }

    // bytes contractAddress = 2;

    pub fn clear_contractAddress(&mut self) {
        self.contractAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.contractAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contractAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contractAddress
    }

    // Take field
    pub fn take_contractAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contractAddress, ::std::vec::Vec::new())
    }

    pub fn get_contractAddress(&self) -> &[u8] {
        &self.contractAddress
    }
}

impl ::protobuf::Message for rsp_contractDeploy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contractAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        if !self.contractAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contractAddress);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        if !self.contractAddress.is_empty() {
            os.write_bytes(2, &self.contractAddress)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_contractDeploy {
        rsp_contractDeploy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &rsp_contractDeploy| { &m.txHash },
                    |m: &mut rsp_contractDeploy| { &mut m.txHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contractAddress",
                    |m: &rsp_contractDeploy| { &m.contractAddress },
                    |m: &mut rsp_contractDeploy| { &mut m.contractAddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_contractDeploy>(
                    "rsp_contractDeploy",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_contractDeploy {
        static mut instance: ::protobuf::lazy::Lazy<rsp_contractDeploy> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_contractDeploy,
        };
        unsafe {
            instance.get(rsp_contractDeploy::new)
        }
    }
}

impl ::protobuf::Clear for rsp_contractDeploy {
    fn clear(&mut self) {
        self.clear_txHash();
        self.clear_contractAddress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_contractDeploy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_contractDeploy {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_call {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub nrg: u64,
    pub nrgPrice: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_call {
    pub fn new() -> req_call {
        ::std::default::Default::default()
    }

    // bytes from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 2;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // bytes value = 4;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // uint64 nrg = 5;

    pub fn clear_nrg(&mut self) {
        self.nrg = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrg(&mut self, v: u64) {
        self.nrg = v;
    }

    pub fn get_nrg(&self) -> u64 {
        self.nrg
    }

    // uint64 nrgPrice = 6;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }
}

impl ::protobuf::Message for req_call {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrg = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.value);
        }
        if self.nrg != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nrg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(6, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(4, &self.value)?;
        }
        if self.nrg != 0 {
            os.write_uint64(5, self.nrg)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(6, self.nrgPrice)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_call {
        req_call::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &req_call| { &m.from },
                    |m: &mut req_call| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &req_call| { &m.to },
                    |m: &mut req_call| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &req_call| { &m.data },
                    |m: &mut req_call| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &req_call| { &m.value },
                    |m: &mut req_call| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrg",
                    |m: &req_call| { &m.nrg },
                    |m: &mut req_call| { &mut m.nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &req_call| { &m.nrgPrice },
                    |m: &mut req_call| { &mut m.nrgPrice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_call>(
                    "req_call",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_call {
        static mut instance: ::protobuf::lazy::Lazy<req_call> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_call,
        };
        unsafe {
            instance.get(req_call::new)
        }
    }
}

impl ::protobuf::Clear for req_call {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_to();
        self.clear_data();
        self.clear_value();
        self.clear_nrg();
        self.clear_nrgPrice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_call {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_call {
    // message fields
    pub result: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_call {
    pub fn new() -> rsp_call {
        ::std::default::Default::default()
    }

    // bytes result = 1;

    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ::std::vec::Vec<u8>) {
        self.result = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.result
    }

    // Take field
    pub fn take_result(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.result, ::std::vec::Vec::new())
    }

    pub fn get_result(&self) -> &[u8] {
        &self.result
    }
}

impl ::protobuf::Message for rsp_call {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.result.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.result.is_empty() {
            os.write_bytes(1, &self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_call {
        rsp_call::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "result",
                    |m: &rsp_call| { &m.result },
                    |m: &mut rsp_call| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_call>(
                    "rsp_call",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_call {
        static mut instance: ::protobuf::lazy::Lazy<rsp_call> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_call,
        };
        unsafe {
            instance.get(rsp_call::new)
        }
    }
}

impl ::protobuf::Clear for rsp_call {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_call {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_call {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockByHash {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockByHash {
    pub fn new() -> req_getBlockByHash {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }
}

impl ::protobuf::Message for req_getBlockByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockByHash {
        req_getBlockByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getBlockByHash| { &m.blockHash },
                    |m: &mut req_getBlockByHash| { &mut m.blockHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockByHash>(
                    "req_getBlockByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockByHash,
        };
        unsafe {
            instance.get(req_getBlockByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockByHash {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockHeaderByHash {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockHeaderByHash {
    pub fn new() -> req_getBlockHeaderByHash {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }
}

impl ::protobuf::Message for req_getBlockHeaderByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockHeaderByHash {
        req_getBlockHeaderByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getBlockHeaderByHash| { &m.blockHash },
                    |m: &mut req_getBlockHeaderByHash| { &mut m.blockHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockHeaderByHash>(
                    "req_getBlockHeaderByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockHeaderByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockHeaderByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockHeaderByHash,
        };
        unsafe {
            instance.get(req_getBlockHeaderByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockHeaderByHash {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockHeaderByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockHeaderByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionCount {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub blocknumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionCount {
    pub fn new() -> req_getTransactionCount {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // uint64 blocknumber = 2;

    pub fn clear_blocknumber(&mut self) {
        self.blocknumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocknumber(&mut self, v: u64) {
        self.blocknumber = v;
    }

    pub fn get_blocknumber(&self) -> u64 {
        self.blocknumber
    }
}

impl ::protobuf::Message for req_getTransactionCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocknumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.blocknumber != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blocknumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.blocknumber != 0 {
            os.write_uint64(2, self.blocknumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionCount {
        req_getTransactionCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &req_getTransactionCount| { &m.address },
                    |m: &mut req_getTransactionCount| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocknumber",
                    |m: &req_getTransactionCount| { &m.blocknumber },
                    |m: &mut req_getTransactionCount| { &mut m.blocknumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionCount>(
                    "req_getTransactionCount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionCount {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionCount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionCount,
        };
        unsafe {
            instance.get(req_getTransactionCount::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionCount {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_blocknumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionCount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getTransactionCount {
    // message fields
    pub txCount: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getTransactionCount {
    pub fn new() -> rsp_getTransactionCount {
        ::std::default::Default::default()
    }

    // uint64 txCount = 1;

    pub fn clear_txCount(&mut self) {
        self.txCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_txCount(&mut self, v: u64) {
        self.txCount = v;
    }

    pub fn get_txCount(&self) -> u64 {
        self.txCount
    }
}

impl ::protobuf::Message for rsp_getTransactionCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.txCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.txCount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.txCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.txCount != 0 {
            os.write_uint64(1, self.txCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getTransactionCount {
        rsp_getTransactionCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "txCount",
                    |m: &rsp_getTransactionCount| { &m.txCount },
                    |m: &mut rsp_getTransactionCount| { &mut m.txCount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getTransactionCount>(
                    "rsp_getTransactionCount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getTransactionCount {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getTransactionCount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getTransactionCount,
        };
        unsafe {
            instance.get(rsp_getTransactionCount::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getTransactionCount {
    fn clear(&mut self) {
        self.clear_txCount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getTransactionCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getTransactionCount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionCountByHash {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionCountByHash {
    pub fn new() -> req_getTransactionCountByHash {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }
}

impl ::protobuf::Message for req_getTransactionCountByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionCountByHash {
        req_getTransactionCountByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &req_getTransactionCountByHash| { &m.txHash },
                    |m: &mut req_getTransactionCountByHash| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionCountByHash>(
                    "req_getTransactionCountByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionCountByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionCountByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionCountByHash,
        };
        unsafe {
            instance.get(req_getTransactionCountByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionCountByHash {
    fn clear(&mut self) {
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionCountByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionCountByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_blockNumber {
    // message fields
    pub blocknumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_blockNumber {
    pub fn new() -> rsp_blockNumber {
        ::std::default::Default::default()
    }

    // uint64 blocknumber = 1;

    pub fn clear_blocknumber(&mut self) {
        self.blocknumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocknumber(&mut self, v: u64) {
        self.blocknumber = v;
    }

    pub fn get_blocknumber(&self) -> u64 {
        self.blocknumber
    }
}

impl ::protobuf::Message for rsp_blockNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocknumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blocknumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blocknumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blocknumber != 0 {
            os.write_uint64(1, self.blocknumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_blockNumber {
        rsp_blockNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocknumber",
                    |m: &rsp_blockNumber| { &m.blocknumber },
                    |m: &mut rsp_blockNumber| { &mut m.blocknumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_blockNumber>(
                    "rsp_blockNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_blockNumber {
        static mut instance: ::protobuf::lazy::Lazy<rsp_blockNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_blockNumber,
        };
        unsafe {
            instance.get(rsp_blockNumber::new)
        }
    }
}

impl ::protobuf::Clear for rsp_blockNumber {
    fn clear(&mut self) {
        self.clear_blocknumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_blockNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_blockNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBalance {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub blockNumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBalance {
    pub fn new() -> req_getBalance {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // uint64 blockNumber = 2;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }
}

impl ::protobuf::Message for req_getBalance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.blockNumber != 0 {
            os.write_uint64(2, self.blockNumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBalance {
        req_getBalance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &req_getBalance| { &m.address },
                    |m: &mut req_getBalance| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &req_getBalance| { &m.blockNumber },
                    |m: &mut req_getBalance| { &mut m.blockNumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBalance>(
                    "req_getBalance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBalance {
        static mut instance: ::protobuf::lazy::Lazy<req_getBalance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBalance,
        };
        unsafe {
            instance.get(req_getBalance::new)
        }
    }
}

impl ::protobuf::Clear for req_getBalance {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_blockNumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBalance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBalance {
    // message fields
    pub balance: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBalance {
    pub fn new() -> rsp_getBalance {
        ::std::default::Default::default()
    }

    // bytes balance = 1;

    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::vec::Vec<u8>) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.balance, ::std::vec::Vec::new())
    }

    pub fn get_balance(&self) -> &[u8] {
        &self.balance
    }
}

impl ::protobuf::Message for rsp_getBalance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.balance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.balance);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.balance.is_empty() {
            os.write_bytes(1, &self.balance)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBalance {
        rsp_getBalance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "balance",
                    |m: &rsp_getBalance| { &m.balance },
                    |m: &mut rsp_getBalance| { &mut m.balance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBalance>(
                    "rsp_getBalance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBalance {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBalance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBalance,
        };
        unsafe {
            instance.get(rsp_getBalance::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBalance {
    fn clear(&mut self) {
        self.clear_balance();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBalance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBalance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getStorageAt {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub position: u32,
    pub blocknumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getStorageAt {
    pub fn new() -> req_getStorageAt {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // uint32 position = 2;

    pub fn clear_position(&mut self) {
        self.position = 0;
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = v;
    }

    pub fn get_position(&self) -> u32 {
        self.position
    }

    // uint64 blocknumber = 3;

    pub fn clear_blocknumber(&mut self) {
        self.blocknumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blocknumber(&mut self, v: u64) {
        self.blocknumber = v;
    }

    pub fn get_blocknumber(&self) -> u64 {
        self.blocknumber
    }
}

impl ::protobuf::Message for req_getStorageAt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.position = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blocknumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if self.position != 0 {
            my_size += ::protobuf::rt::value_size(2, self.position, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blocknumber != 0 {
            my_size += ::protobuf::rt::value_size(3, self.blocknumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if self.position != 0 {
            os.write_uint32(2, self.position)?;
        }
        if self.blocknumber != 0 {
            os.write_uint64(3, self.blocknumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getStorageAt {
        req_getStorageAt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &req_getStorageAt| { &m.address },
                    |m: &mut req_getStorageAt| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "position",
                    |m: &req_getStorageAt| { &m.position },
                    |m: &mut req_getStorageAt| { &mut m.position },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blocknumber",
                    |m: &req_getStorageAt| { &m.blocknumber },
                    |m: &mut req_getStorageAt| { &mut m.blocknumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getStorageAt>(
                    "req_getStorageAt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getStorageAt {
        static mut instance: ::protobuf::lazy::Lazy<req_getStorageAt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getStorageAt,
        };
        unsafe {
            instance.get(req_getStorageAt::new)
        }
    }
}

impl ::protobuf::Clear for req_getStorageAt {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_position();
        self.clear_blocknumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getStorageAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getStorageAt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getStorageAt {
    // message fields
    pub storage: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getStorageAt {
    pub fn new() -> rsp_getStorageAt {
        ::std::default::Default::default()
    }

    // string storage = 1;

    pub fn clear_storage(&mut self) {
        self.storage.clear();
    }

    // Param is passed by value, moved
    pub fn set_storage(&mut self, v: ::std::string::String) {
        self.storage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storage(&mut self) -> &mut ::std::string::String {
        &mut self.storage
    }

    // Take field
    pub fn take_storage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.storage, ::std::string::String::new())
    }

    pub fn get_storage(&self) -> &str {
        &self.storage
    }
}

impl ::protobuf::Message for rsp_getStorageAt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.storage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.storage.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.storage);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.storage.is_empty() {
            os.write_string(1, &self.storage)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getStorageAt {
        rsp_getStorageAt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "storage",
                    |m: &rsp_getStorageAt| { &m.storage },
                    |m: &mut rsp_getStorageAt| { &mut m.storage },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getStorageAt>(
                    "rsp_getStorageAt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getStorageAt {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getStorageAt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getStorageAt,
        };
        unsafe {
            instance.get(rsp_getStorageAt::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getStorageAt {
    fn clear(&mut self) {
        self.clear_storage();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getStorageAt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getStorageAt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockTransactionCountByHash {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockTransactionCountByHash {
    pub fn new() -> req_getBlockTransactionCountByHash {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }
}

impl ::protobuf::Message for req_getBlockTransactionCountByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockTransactionCountByHash {
        req_getBlockTransactionCountByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getBlockTransactionCountByHash| { &m.blockHash },
                    |m: &mut req_getBlockTransactionCountByHash| { &mut m.blockHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockTransactionCountByHash>(
                    "req_getBlockTransactionCountByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockTransactionCountByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockTransactionCountByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockTransactionCountByHash,
        };
        unsafe {
            instance.get(req_getBlockTransactionCountByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockTransactionCountByHash {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockTransactionCountByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockTransactionCountByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockTransactionCount {
    // message fields
    pub txCount: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockTransactionCount {
    pub fn new() -> rsp_getBlockTransactionCount {
        ::std::default::Default::default()
    }

    // uint32 txCount = 1;

    pub fn clear_txCount(&mut self) {
        self.txCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_txCount(&mut self, v: u32) {
        self.txCount = v;
    }

    pub fn get_txCount(&self) -> u32 {
        self.txCount
    }
}

impl ::protobuf::Message for rsp_getBlockTransactionCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.txCount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.txCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.txCount != 0 {
            os.write_uint32(1, self.txCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockTransactionCount {
        rsp_getBlockTransactionCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txCount",
                    |m: &rsp_getBlockTransactionCount| { &m.txCount },
                    |m: &mut rsp_getBlockTransactionCount| { &mut m.txCount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockTransactionCount>(
                    "rsp_getBlockTransactionCount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockTransactionCount {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockTransactionCount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockTransactionCount,
        };
        unsafe {
            instance.get(rsp_getBlockTransactionCount::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockTransactionCount {
    fn clear(&mut self) {
        self.clear_txCount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockTransactionCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockTransactionCount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockTransactionCountByNumber {
    // message fields
    pub blockNumber: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockTransactionCountByNumber {
    pub fn new() -> req_getBlockTransactionCountByNumber {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }
}

impl ::protobuf::Message for req_getBlockTransactionCountByNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockTransactionCountByNumber {
        req_getBlockTransactionCountByNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &req_getBlockTransactionCountByNumber| { &m.blockNumber },
                    |m: &mut req_getBlockTransactionCountByNumber| { &mut m.blockNumber },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockTransactionCountByNumber>(
                    "req_getBlockTransactionCountByNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockTransactionCountByNumber {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockTransactionCountByNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockTransactionCountByNumber,
        };
        unsafe {
            instance.get(req_getBlockTransactionCountByNumber::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockTransactionCountByNumber {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockTransactionCountByNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockTransactionCountByNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionByBlockHashAndIndex {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    pub txIndex: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionByBlockHashAndIndex {
    pub fn new() -> req_getTransactionByBlockHashAndIndex {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }

    // uint32 txIndex = 2;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }
}

impl ::protobuf::Message for req_getTransactionByBlockHashAndIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(2, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        if self.txIndex != 0 {
            os.write_uint32(2, self.txIndex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionByBlockHashAndIndex {
        req_getTransactionByBlockHashAndIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getTransactionByBlockHashAndIndex| { &m.blockHash },
                    |m: &mut req_getTransactionByBlockHashAndIndex| { &mut m.blockHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &req_getTransactionByBlockHashAndIndex| { &m.txIndex },
                    |m: &mut req_getTransactionByBlockHashAndIndex| { &mut m.txIndex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionByBlockHashAndIndex>(
                    "req_getTransactionByBlockHashAndIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionByBlockHashAndIndex {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionByBlockHashAndIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionByBlockHashAndIndex,
        };
        unsafe {
            instance.get(req_getTransactionByBlockHashAndIndex::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionByBlockHashAndIndex {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.clear_txIndex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionByBlockHashAndIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionByBlockHashAndIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionByBlockNumberAndIndex {
    // message fields
    pub blockNumber: u64,
    pub txIndex: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionByBlockNumberAndIndex {
    pub fn new() -> req_getTransactionByBlockNumberAndIndex {
        ::std::default::Default::default()
    }

    // uint64 blockNumber = 1;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint32 txIndex = 2;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }
}

impl ::protobuf::Message for req_getTransactionByBlockNumberAndIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(2, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blockNumber != 0 {
            os.write_uint64(1, self.blockNumber)?;
        }
        if self.txIndex != 0 {
            os.write_uint32(2, self.txIndex)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionByBlockNumberAndIndex {
        req_getTransactionByBlockNumberAndIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &req_getTransactionByBlockNumberAndIndex| { &m.blockNumber },
                    |m: &mut req_getTransactionByBlockNumberAndIndex| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &req_getTransactionByBlockNumberAndIndex| { &m.txIndex },
                    |m: &mut req_getTransactionByBlockNumberAndIndex| { &mut m.txIndex },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionByBlockNumberAndIndex>(
                    "req_getTransactionByBlockNumberAndIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionByBlockNumberAndIndex {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionByBlockNumberAndIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionByBlockNumberAndIndex,
        };
        unsafe {
            instance.get(req_getTransactionByBlockNumberAndIndex::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionByBlockNumberAndIndex {
    fn clear(&mut self) {
        self.clear_blockNumber();
        self.clear_txIndex();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionByBlockNumberAndIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionByBlockNumberAndIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getTransactionReceipt {
    // message fields
    pub txHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getTransactionReceipt {
    pub fn new() -> req_getTransactionReceipt {
        ::std::default::Default::default()
    }

    // bytes txHash = 1;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }
}

impl ::protobuf::Message for req_getTransactionReceipt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.txHash.is_empty() {
            os.write_bytes(1, &self.txHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getTransactionReceipt {
        req_getTransactionReceipt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &req_getTransactionReceipt| { &m.txHash },
                    |m: &mut req_getTransactionReceipt| { &mut m.txHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getTransactionReceipt>(
                    "req_getTransactionReceipt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getTransactionReceipt {
        static mut instance: ::protobuf::lazy::Lazy<req_getTransactionReceipt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getTransactionReceipt,
        };
        unsafe {
            instance.get(req_getTransactionReceipt::new)
        }
    }
}

impl ::protobuf::Clear for req_getTransactionReceipt {
    fn clear(&mut self) {
        self.clear_txHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getTransactionReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getTransactionReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getTransactionReceipt {
    // message fields
    pub txIndex: u32,
    pub blockNumber: u64,
    pub nrgConsumed: u64,
    pub cumulativeNrgUsed: u64,
    pub blockHash: ::std::vec::Vec<u8>,
    pub txHash: ::std::vec::Vec<u8>,
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub contractAddress: ::std::vec::Vec<u8>,
    pub logs: ::protobuf::RepeatedField<t_LgEle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getTransactionReceipt {
    pub fn new() -> rsp_getTransactionReceipt {
        ::std::default::Default::default()
    }

    // uint32 txIndex = 1;

    pub fn clear_txIndex(&mut self) {
        self.txIndex = 0;
    }

    // Param is passed by value, moved
    pub fn set_txIndex(&mut self, v: u32) {
        self.txIndex = v;
    }

    pub fn get_txIndex(&self) -> u32 {
        self.txIndex
    }

    // uint64 blockNumber = 2;

    pub fn clear_blockNumber(&mut self) {
        self.blockNumber = 0;
    }

    // Param is passed by value, moved
    pub fn set_blockNumber(&mut self, v: u64) {
        self.blockNumber = v;
    }

    pub fn get_blockNumber(&self) -> u64 {
        self.blockNumber
    }

    // uint64 nrgConsumed = 3;

    pub fn clear_nrgConsumed(&mut self) {
        self.nrgConsumed = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgConsumed(&mut self, v: u64) {
        self.nrgConsumed = v;
    }

    pub fn get_nrgConsumed(&self) -> u64 {
        self.nrgConsumed
    }

    // uint64 cumulativeNrgUsed = 4;

    pub fn clear_cumulativeNrgUsed(&mut self) {
        self.cumulativeNrgUsed = 0;
    }

    // Param is passed by value, moved
    pub fn set_cumulativeNrgUsed(&mut self, v: u64) {
        self.cumulativeNrgUsed = v;
    }

    pub fn get_cumulativeNrgUsed(&self) -> u64 {
        self.cumulativeNrgUsed
    }

    // bytes blockHash = 5;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }

    // bytes txHash = 6;

    pub fn clear_txHash(&mut self) {
        self.txHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_txHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.txHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txHash
    }

    // Take field
    pub fn take_txHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txHash, ::std::vec::Vec::new())
    }

    pub fn get_txHash(&self) -> &[u8] {
        &self.txHash
    }

    // bytes from = 7;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 8;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes contractAddress = 9;

    pub fn clear_contractAddress(&mut self) {
        self.contractAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.contractAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contractAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contractAddress
    }

    // Take field
    pub fn take_contractAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contractAddress, ::std::vec::Vec::new())
    }

    pub fn get_contractAddress(&self) -> &[u8] {
        &self.contractAddress
    }

    // repeated .bp_api.t_LgEle logs = 10;

    pub fn clear_logs(&mut self) {
        self.logs.clear();
    }

    // Param is passed by value, moved
    pub fn set_logs(&mut self, v: ::protobuf::RepeatedField<t_LgEle>) {
        self.logs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logs(&mut self) -> &mut ::protobuf::RepeatedField<t_LgEle> {
        &mut self.logs
    }

    // Take field
    pub fn take_logs(&mut self) -> ::protobuf::RepeatedField<t_LgEle> {
        ::std::mem::replace(&mut self.logs, ::protobuf::RepeatedField::new())
    }

    pub fn get_logs(&self) -> &[t_LgEle] {
        &self.logs
    }
}

impl ::protobuf::Message for rsp_getTransactionReceipt {
    fn is_initialized(&self) -> bool {
        for v in &self.logs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.txIndex = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blockNumber = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgConsumed = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.cumulativeNrgUsed = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txHash)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contractAddress)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.txIndex != 0 {
            my_size += ::protobuf::rt::value_size(1, self.txIndex, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blockNumber != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blockNumber, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgConsumed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nrgConsumed, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cumulativeNrgUsed != 0 {
            my_size += ::protobuf::rt::value_size(4, self.cumulativeNrgUsed, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.blockHash);
        }
        if !self.txHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.txHash);
        }
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.to);
        }
        if !self.contractAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.contractAddress);
        }
        for value in &self.logs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.txIndex != 0 {
            os.write_uint32(1, self.txIndex)?;
        }
        if self.blockNumber != 0 {
            os.write_uint64(2, self.blockNumber)?;
        }
        if self.nrgConsumed != 0 {
            os.write_uint64(3, self.nrgConsumed)?;
        }
        if self.cumulativeNrgUsed != 0 {
            os.write_uint64(4, self.cumulativeNrgUsed)?;
        }
        if !self.blockHash.is_empty() {
            os.write_bytes(5, &self.blockHash)?;
        }
        if !self.txHash.is_empty() {
            os.write_bytes(6, &self.txHash)?;
        }
        if !self.from.is_empty() {
            os.write_bytes(7, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(8, &self.to)?;
        }
        if !self.contractAddress.is_empty() {
            os.write_bytes(9, &self.contractAddress)?;
        }
        for v in &self.logs {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getTransactionReceipt {
        rsp_getTransactionReceipt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "txIndex",
                    |m: &rsp_getTransactionReceipt| { &m.txIndex },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.txIndex },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blockNumber",
                    |m: &rsp_getTransactionReceipt| { &m.blockNumber },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.blockNumber },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgConsumed",
                    |m: &rsp_getTransactionReceipt| { &m.nrgConsumed },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.nrgConsumed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "cumulativeNrgUsed",
                    |m: &rsp_getTransactionReceipt| { &m.cumulativeNrgUsed },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.cumulativeNrgUsed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &rsp_getTransactionReceipt| { &m.blockHash },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.blockHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txHash",
                    |m: &rsp_getTransactionReceipt| { &m.txHash },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.txHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &rsp_getTransactionReceipt| { &m.from },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &rsp_getTransactionReceipt| { &m.to },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contractAddress",
                    |m: &rsp_getTransactionReceipt| { &m.contractAddress },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.contractAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_LgEle>>(
                    "logs",
                    |m: &rsp_getTransactionReceipt| { &m.logs },
                    |m: &mut rsp_getTransactionReceipt| { &mut m.logs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getTransactionReceipt>(
                    "rsp_getTransactionReceipt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getTransactionReceipt {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getTransactionReceipt> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getTransactionReceipt,
        };
        unsafe {
            instance.get(rsp_getTransactionReceipt::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getTransactionReceipt {
    fn clear(&mut self) {
        self.clear_txIndex();
        self.clear_blockNumber();
        self.clear_nrgConsumed();
        self.clear_cumulativeNrgUsed();
        self.clear_blockHash();
        self.clear_txHash();
        self.clear_from();
        self.clear_to();
        self.clear_contractAddress();
        self.clear_logs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getTransactionReceipt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getTransactionReceipt {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getUncleByBlockHashAndIndex {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    pub index: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getUncleByBlockHashAndIndex {
    pub fn new() -> req_getUncleByBlockHashAndIndex {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }

    // uint32 index = 2;

    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = v;
    }

    pub fn get_index(&self) -> u32 {
        self.index
    }
}

impl ::protobuf::Message for req_getUncleByBlockHashAndIndex {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(2, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        if self.index != 0 {
            os.write_uint32(2, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getUncleByBlockHashAndIndex {
        req_getUncleByBlockHashAndIndex::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getUncleByBlockHashAndIndex| { &m.blockHash },
                    |m: &mut req_getUncleByBlockHashAndIndex| { &mut m.blockHash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "index",
                    |m: &req_getUncleByBlockHashAndIndex| { &m.index },
                    |m: &mut req_getUncleByBlockHashAndIndex| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getUncleByBlockHashAndIndex>(
                    "req_getUncleByBlockHashAndIndex",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getUncleByBlockHashAndIndex {
        static mut instance: ::protobuf::lazy::Lazy<req_getUncleByBlockHashAndIndex> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getUncleByBlockHashAndIndex,
        };
        unsafe {
            instance.get(req_getUncleByBlockHashAndIndex::new)
        }
    }
}

impl ::protobuf::Clear for req_getUncleByBlockHashAndIndex {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.clear_index();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getUncleByBlockHashAndIndex {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getUncleByBlockHashAndIndex {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getCompilers {
    // message fields
    pub compiler: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getCompilers {
    pub fn new() -> rsp_getCompilers {
        ::std::default::Default::default()
    }

    // repeated string compiler = 1;

    pub fn clear_compiler(&mut self) {
        self.compiler.clear();
    }

    // Param is passed by value, moved
    pub fn set_compiler(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.compiler = v;
    }

    // Mutable pointer to the field.
    pub fn mut_compiler(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.compiler
    }

    // Take field
    pub fn take_compiler(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.compiler, ::protobuf::RepeatedField::new())
    }

    pub fn get_compiler(&self) -> &[::std::string::String] {
        &self.compiler
    }
}

impl ::protobuf::Message for rsp_getCompilers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.compiler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.compiler {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.compiler {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getCompilers {
        rsp_getCompilers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "compiler",
                    |m: &rsp_getCompilers| { &m.compiler },
                    |m: &mut rsp_getCompilers| { &mut m.compiler },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getCompilers>(
                    "rsp_getCompilers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getCompilers {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getCompilers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getCompilers,
        };
        unsafe {
            instance.get(rsp_getCompilers::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getCompilers {
    fn clear(&mut self) {
        self.clear_compiler();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getCompilers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getCompilers {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_compileSolidity {
    // message fields
    pub source: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_compileSolidity {
    pub fn new() -> req_compileSolidity {
        ::std::default::Default::default()
    }

    // string source = 1;

    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        &mut self.source
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source, ::std::string::String::new())
    }

    pub fn get_source(&self) -> &str {
        &self.source
    }
}

impl ::protobuf::Message for req_compileSolidity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.source.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.source);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.source.is_empty() {
            os.write_string(1, &self.source)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_compileSolidity {
        req_compileSolidity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "source",
                    |m: &req_compileSolidity| { &m.source },
                    |m: &mut req_compileSolidity| { &mut m.source },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_compileSolidity>(
                    "req_compileSolidity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_compileSolidity {
        static mut instance: ::protobuf::lazy::Lazy<req_compileSolidity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_compileSolidity,
        };
        unsafe {
            instance.get(req_compileSolidity::new)
        }
    }
}

impl ::protobuf::Clear for req_compileSolidity {
    fn clear(&mut self) {
        self.clear_source();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_compileSolidity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_compileSolidity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_compileSolidity {
    // message fields
    pub code: ::std::string::String,
    pub info: ::protobuf::SingularPtrField<t_Contract>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_compileSolidity {
    pub fn new() -> rsp_compileSolidity {
        ::std::default::Default::default()
    }

    // string code = 1;

    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::string::String) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::string::String {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.code, ::std::string::String::new())
    }

    pub fn get_code(&self) -> &str {
        &self.code
    }

    // .bp_api.t_Contract info = 2;

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: t_Contract) {
        self.info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut t_Contract {
        if self.info.is_none() {
            self.info.set_default();
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> t_Contract {
        self.info.take().unwrap_or_else(|| t_Contract::new())
    }

    pub fn get_info(&self) -> &t_Contract {
        self.info.as_ref().unwrap_or_else(|| t_Contract::default_instance())
    }
}

impl ::protobuf::Message for rsp_compileSolidity {
    fn is_initialized(&self) -> bool {
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.code)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.code);
        }
        if let Some(ref v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.code.is_empty() {
            os.write_string(1, &self.code)?;
        }
        if let Some(ref v) = self.info.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_compileSolidity {
        rsp_compileSolidity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "code",
                    |m: &rsp_compileSolidity| { &m.code },
                    |m: &mut rsp_compileSolidity| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_Contract>>(
                    "info",
                    |m: &rsp_compileSolidity| { &m.info },
                    |m: &mut rsp_compileSolidity| { &mut m.info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_compileSolidity>(
                    "rsp_compileSolidity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_compileSolidity {
        static mut instance: ::protobuf::lazy::Lazy<rsp_compileSolidity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_compileSolidity,
        };
        unsafe {
            instance.get(rsp_compileSolidity::new)
        }
    }
}

impl ::protobuf::Clear for rsp_compileSolidity {
    fn clear(&mut self) {
        self.clear_code();
        self.clear_info();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_compileSolidity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_compileSolidity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getWork {
    // message fields
    pub work: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getWork {
    pub fn new() -> rsp_getWork {
        ::std::default::Default::default()
    }

    // repeated string work = 1;

    pub fn clear_work(&mut self) {
        self.work.clear();
    }

    // Param is passed by value, moved
    pub fn set_work(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.work = v;
    }

    // Mutable pointer to the field.
    pub fn mut_work(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.work
    }

    // Take field
    pub fn take_work(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.work, ::protobuf::RepeatedField::new())
    }

    pub fn get_work(&self) -> &[::std::string::String] {
        &self.work
    }
}

impl ::protobuf::Message for rsp_getWork {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.work)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.work {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.work {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getWork {
        rsp_getWork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "work",
                    |m: &rsp_getWork| { &m.work },
                    |m: &mut rsp_getWork| { &mut m.work },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getWork>(
                    "rsp_getWork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getWork {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getWork> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getWork,
        };
        unsafe {
            instance.get(rsp_getWork::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getWork {
    fn clear(&mut self) {
        self.clear_work();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getWork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getWork {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_submitWork {
    // message fields
    pub nonce: ::std::vec::Vec<u8>,
    pub solution: ::std::vec::Vec<u8>,
    pub digest: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_submitWork {
    pub fn new() -> req_submitWork {
        ::std::default::Default::default()
    }

    // bytes nonce = 1;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }

    // bytes solution = 2;

    pub fn clear_solution(&mut self) {
        self.solution.clear();
    }

    // Param is passed by value, moved
    pub fn set_solution(&mut self, v: ::std::vec::Vec<u8>) {
        self.solution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_solution(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.solution
    }

    // Take field
    pub fn take_solution(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.solution, ::std::vec::Vec::new())
    }

    pub fn get_solution(&self) -> &[u8] {
        &self.solution
    }

    // bytes digest = 3;

    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.digest
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.digest, ::std::vec::Vec::new())
    }

    pub fn get_digest(&self) -> &[u8] {
        &self.digest
    }
}

impl ::protobuf::Message for req_submitWork {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.solution)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.digest)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.nonce);
        }
        if !self.solution.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.solution);
        }
        if !self.digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.digest);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.nonce.is_empty() {
            os.write_bytes(1, &self.nonce)?;
        }
        if !self.solution.is_empty() {
            os.write_bytes(2, &self.solution)?;
        }
        if !self.digest.is_empty() {
            os.write_bytes(3, &self.digest)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_submitWork {
        req_submitWork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &req_submitWork| { &m.nonce },
                    |m: &mut req_submitWork| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "solution",
                    |m: &req_submitWork| { &m.solution },
                    |m: &mut req_submitWork| { &mut m.solution },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "digest",
                    |m: &req_submitWork| { &m.digest },
                    |m: &mut req_submitWork| { &mut m.digest },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_submitWork>(
                    "req_submitWork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_submitWork {
        static mut instance: ::protobuf::lazy::Lazy<req_submitWork> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_submitWork,
        };
        unsafe {
            instance.get(req_submitWork::new)
        }
    }
}

impl ::protobuf::Clear for req_submitWork {
    fn clear(&mut self) {
        self.clear_nonce();
        self.clear_solution();
        self.clear_digest();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_submitWork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_submitWork {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_submitWork {
    // message fields
    pub workAccepted: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_submitWork {
    pub fn new() -> rsp_submitWork {
        ::std::default::Default::default()
    }

    // bool workAccepted = 1;

    pub fn clear_workAccepted(&mut self) {
        self.workAccepted = false;
    }

    // Param is passed by value, moved
    pub fn set_workAccepted(&mut self, v: bool) {
        self.workAccepted = v;
    }

    pub fn get_workAccepted(&self) -> bool {
        self.workAccepted
    }
}

impl ::protobuf::Message for rsp_submitWork {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.workAccepted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.workAccepted != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.workAccepted != false {
            os.write_bool(1, self.workAccepted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_submitWork {
        rsp_submitWork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "workAccepted",
                    |m: &rsp_submitWork| { &m.workAccepted },
                    |m: &mut rsp_submitWork| { &mut m.workAccepted },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_submitWork>(
                    "rsp_submitWork",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_submitWork {
        static mut instance: ::protobuf::lazy::Lazy<rsp_submitWork> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_submitWork,
        };
        unsafe {
            instance.get(rsp_submitWork::new)
        }
    }
}

impl ::protobuf::Clear for rsp_submitWork {
    fn clear(&mut self) {
        self.clear_workAccepted();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_submitWork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_submitWork {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_fetchQueuedTransactions {
    // message fields
    pub tx: ::protobuf::RepeatedField<t_AionTx>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_fetchQueuedTransactions {
    pub fn new() -> rsp_fetchQueuedTransactions {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_AionTx tx = 1;

    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: ::protobuf::RepeatedField<t_AionTx>) {
        self.tx = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx(&mut self) -> &mut ::protobuf::RepeatedField<t_AionTx> {
        &mut self.tx
    }

    // Take field
    pub fn take_tx(&mut self) -> ::protobuf::RepeatedField<t_AionTx> {
        ::std::mem::replace(&mut self.tx, ::protobuf::RepeatedField::new())
    }

    pub fn get_tx(&self) -> &[t_AionTx] {
        &self.tx
    }
}

impl ::protobuf::Message for rsp_fetchQueuedTransactions {
    fn is_initialized(&self) -> bool {
        for v in &self.tx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tx {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tx {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_fetchQueuedTransactions {
        rsp_fetchQueuedTransactions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_AionTx>>(
                    "tx",
                    |m: &rsp_fetchQueuedTransactions| { &m.tx },
                    |m: &mut rsp_fetchQueuedTransactions| { &mut m.tx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_fetchQueuedTransactions>(
                    "rsp_fetchQueuedTransactions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_fetchQueuedTransactions {
        static mut instance: ::protobuf::lazy::Lazy<rsp_fetchQueuedTransactions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_fetchQueuedTransactions,
        };
        unsafe {
            instance.get(rsp_fetchQueuedTransactions::new)
        }
    }
}

impl ::protobuf::Clear for rsp_fetchQueuedTransactions {
    fn clear(&mut self) {
        self.clear_tx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_fetchQueuedTransactions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_fetchQueuedTransactions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_rawTransaction {
    // message fields
    pub encodedTx: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_rawTransaction {
    pub fn new() -> req_rawTransaction {
        ::std::default::Default::default()
    }

    // bytes encodedTx = 1;

    pub fn clear_encodedTx(&mut self) {
        self.encodedTx.clear();
    }

    // Param is passed by value, moved
    pub fn set_encodedTx(&mut self, v: ::std::vec::Vec<u8>) {
        self.encodedTx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encodedTx(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encodedTx
    }

    // Take field
    pub fn take_encodedTx(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encodedTx, ::std::vec::Vec::new())
    }

    pub fn get_encodedTx(&self) -> &[u8] {
        &self.encodedTx
    }
}

impl ::protobuf::Message for req_rawTransaction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encodedTx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.encodedTx.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.encodedTx);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.encodedTx.is_empty() {
            os.write_bytes(1, &self.encodedTx)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_rawTransaction {
        req_rawTransaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "encodedTx",
                    |m: &req_rawTransaction| { &m.encodedTx },
                    |m: &mut req_rawTransaction| { &mut m.encodedTx },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_rawTransaction>(
                    "req_rawTransaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_rawTransaction {
        static mut instance: ::protobuf::lazy::Lazy<req_rawTransaction> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_rawTransaction,
        };
        unsafe {
            instance.get(req_rawTransaction::new)
        }
    }
}

impl ::protobuf::Clear for req_rawTransaction {
    fn clear(&mut self) {
        self.clear_encodedTx();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_rawTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_rawTransaction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_estimateNrg {
    // message fields
    pub from: ::std::vec::Vec<u8>,
    pub to: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub data: ::std::vec::Vec<u8>,
    pub nrg: u64,
    pub nrgPrice: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_estimateNrg {
    pub fn new() -> req_estimateNrg {
        ::std::default::Default::default()
    }

    // bytes from = 1;

    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::vec::Vec<u8>) {
        self.from = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from, ::std::vec::Vec::new())
    }

    pub fn get_from(&self) -> &[u8] {
        &self.from
    }

    // bytes to = 2;

    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::vec::Vec<u8>) {
        self.to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to, ::std::vec::Vec::new())
    }

    pub fn get_to(&self) -> &[u8] {
        &self.to
    }

    // bytes value = 3;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }

    pub fn get_value(&self) -> &[u8] {
        &self.value
    }

    // bytes data = 4;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    pub fn get_data(&self) -> &[u8] {
        &self.data
    }

    // uint64 nrg = 5;

    pub fn clear_nrg(&mut self) {
        self.nrg = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrg(&mut self, v: u64) {
        self.nrg = v;
    }

    pub fn get_nrg(&self) -> u64 {
        self.nrg
    }

    // uint64 nrgPrice = 6;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }
}

impl ::protobuf::Message for req_estimateNrg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.data)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrg = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.from.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.from);
        }
        if !self.to.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        if self.nrg != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nrg, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(6, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.from.is_empty() {
            os.write_bytes(1, &self.from)?;
        }
        if !self.to.is_empty() {
            os.write_bytes(2, &self.to)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        if self.nrg != 0 {
            os.write_uint64(5, self.nrg)?;
        }
        if self.nrgPrice != 0 {
            os.write_uint64(6, self.nrgPrice)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_estimateNrg {
        req_estimateNrg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from",
                    |m: &req_estimateNrg| { &m.from },
                    |m: &mut req_estimateNrg| { &mut m.from },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to",
                    |m: &req_estimateNrg| { &m.to },
                    |m: &mut req_estimateNrg| { &mut m.to },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &req_estimateNrg| { &m.value },
                    |m: &mut req_estimateNrg| { &mut m.value },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "data",
                    |m: &req_estimateNrg| { &m.data },
                    |m: &mut req_estimateNrg| { &mut m.data },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrg",
                    |m: &req_estimateNrg| { &m.nrg },
                    |m: &mut req_estimateNrg| { &mut m.nrg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &req_estimateNrg| { &m.nrgPrice },
                    |m: &mut req_estimateNrg| { &mut m.nrgPrice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_estimateNrg>(
                    "req_estimateNrg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_estimateNrg {
        static mut instance: ::protobuf::lazy::Lazy<req_estimateNrg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_estimateNrg,
        };
        unsafe {
            instance.get(req_estimateNrg::new)
        }
    }
}

impl ::protobuf::Clear for req_estimateNrg {
    fn clear(&mut self) {
        self.clear_from();
        self.clear_to();
        self.clear_value();
        self.clear_data();
        self.clear_nrg();
        self.clear_nrgPrice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_estimateNrg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_estimateNrg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_estimateNrg {
    // message fields
    pub nrg: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_estimateNrg {
    pub fn new() -> rsp_estimateNrg {
        ::std::default::Default::default()
    }

    // uint64 nrg = 1;

    pub fn clear_nrg(&mut self) {
        self.nrg = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrg(&mut self, v: u64) {
        self.nrg = v;
    }

    pub fn get_nrg(&self) -> u64 {
        self.nrg
    }
}

impl ::protobuf::Message for rsp_estimateNrg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nrg != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nrg, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.nrg != 0 {
            os.write_uint64(1, self.nrg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_estimateNrg {
        rsp_estimateNrg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrg",
                    |m: &rsp_estimateNrg| { &m.nrg },
                    |m: &mut rsp_estimateNrg| { &mut m.nrg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_estimateNrg>(
                    "rsp_estimateNrg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_estimateNrg {
        static mut instance: ::protobuf::lazy::Lazy<rsp_estimateNrg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_estimateNrg,
        };
        unsafe {
            instance.get(rsp_estimateNrg::new)
        }
    }
}

impl ::protobuf::Clear for rsp_estimateNrg {
    fn clear(&mut self) {
        self.clear_nrg();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_estimateNrg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_estimateNrg {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_mining {
    // message fields
    pub mining: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_mining {
    pub fn new() -> rsp_mining {
        ::std::default::Default::default()
    }

    // bool mining = 1;

    pub fn clear_mining(&mut self) {
        self.mining = false;
    }

    // Param is passed by value, moved
    pub fn set_mining(&mut self, v: bool) {
        self.mining = v;
    }

    pub fn get_mining(&self) -> bool {
        self.mining
    }
}

impl ::protobuf::Message for rsp_mining {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mining = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mining != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.mining != false {
            os.write_bool(1, self.mining)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_mining {
        rsp_mining::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "mining",
                    |m: &rsp_mining| { &m.mining },
                    |m: &mut rsp_mining| { &mut m.mining },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_mining>(
                    "rsp_mining",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_mining {
        static mut instance: ::protobuf::lazy::Lazy<rsp_mining> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_mining,
        };
        unsafe {
            instance.get(rsp_mining::new)
        }
    }
}

impl ::protobuf::Clear for rsp_mining {
    fn clear(&mut self) {
        self.clear_mining();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_mining {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_mining {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_hashrate {
    // message fields
    pub hashrate: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_hashrate {
    pub fn new() -> rsp_hashrate {
        ::std::default::Default::default()
    }

    // uint64 hashrate = 1;

    pub fn clear_hashrate(&mut self) {
        self.hashrate = 0;
    }

    // Param is passed by value, moved
    pub fn set_hashrate(&mut self, v: u64) {
        self.hashrate = v;
    }

    pub fn get_hashrate(&self) -> u64 {
        self.hashrate
    }
}

impl ::protobuf::Message for rsp_hashrate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.hashrate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hashrate != 0 {
            my_size += ::protobuf::rt::value_size(1, self.hashrate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.hashrate != 0 {
            os.write_uint64(1, self.hashrate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_hashrate {
        rsp_hashrate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "hashrate",
                    |m: &rsp_hashrate| { &m.hashrate },
                    |m: &mut rsp_hashrate| { &mut m.hashrate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_hashrate>(
                    "rsp_hashrate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_hashrate {
        static mut instance: ::protobuf::lazy::Lazy<rsp_hashrate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_hashrate,
        };
        unsafe {
            instance.get(rsp_hashrate::new)
        }
    }
}

impl ::protobuf::Clear for rsp_hashrate {
    fn clear(&mut self) {
        self.clear_hashrate();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_hashrate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_hashrate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getActiveNodes {
    // message fields
    pub node: ::protobuf::RepeatedField<t_Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getActiveNodes {
    pub fn new() -> rsp_getActiveNodes {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_Node node = 1;

    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<t_Node>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<t_Node> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<t_Node> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    pub fn get_node(&self) -> &[t_Node] {
        &self.node
    }
}

impl ::protobuf::Message for rsp_getActiveNodes {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getActiveNodes {
        rsp_getActiveNodes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_Node>>(
                    "node",
                    |m: &rsp_getActiveNodes| { &m.node },
                    |m: &mut rsp_getActiveNodes| { &mut m.node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getActiveNodes>(
                    "rsp_getActiveNodes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getActiveNodes {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getActiveNodes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getActiveNodes,
        };
        unsafe {
            instance.get(rsp_getActiveNodes::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getActiveNodes {
    fn clear(&mut self) {
        self.clear_node();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getActiveNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getActiveNodes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getStaticNodes {
    // message fields
    pub node: ::protobuf::RepeatedField<t_Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getStaticNodes {
    pub fn new() -> rsp_getStaticNodes {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_Node node = 1;

    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::protobuf::RepeatedField<t_Node>) {
        self.node = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node(&mut self) -> &mut ::protobuf::RepeatedField<t_Node> {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::protobuf::RepeatedField<t_Node> {
        ::std::mem::replace(&mut self.node, ::protobuf::RepeatedField::new())
    }

    pub fn get_node(&self) -> &[t_Node] {
        &self.node
    }
}

impl ::protobuf::Message for rsp_getStaticNodes {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getStaticNodes {
        rsp_getStaticNodes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_Node>>(
                    "node",
                    |m: &rsp_getStaticNodes| { &m.node },
                    |m: &mut rsp_getStaticNodes| { &mut m.node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getStaticNodes>(
                    "rsp_getStaticNodes",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getStaticNodes {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getStaticNodes> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getStaticNodes,
        };
        unsafe {
            instance.get(rsp_getStaticNodes::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getStaticNodes {
    fn clear(&mut self) {
        self.clear_node();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getStaticNodes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getStaticNodes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getSolcVersion {
    // message fields
    pub ver: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getSolcVersion {
    pub fn new() -> rsp_getSolcVersion {
        ::std::default::Default::default()
    }

    // string ver = 1;

    pub fn clear_ver(&mut self) {
        self.ver.clear();
    }

    // Param is passed by value, moved
    pub fn set_ver(&mut self, v: ::std::string::String) {
        self.ver = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ver(&mut self) -> &mut ::std::string::String {
        &mut self.ver
    }

    // Take field
    pub fn take_ver(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ver, ::std::string::String::new())
    }

    pub fn get_ver(&self) -> &str {
        &self.ver
    }
}

impl ::protobuf::Message for rsp_getSolcVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ver)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ver.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.ver);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ver.is_empty() {
            os.write_string(1, &self.ver)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getSolcVersion {
        rsp_getSolcVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ver",
                    |m: &rsp_getSolcVersion| { &m.ver },
                    |m: &mut rsp_getSolcVersion| { &mut m.ver },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getSolcVersion>(
                    "rsp_getSolcVersion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getSolcVersion {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getSolcVersion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getSolcVersion,
        };
        unsafe {
            instance.get(rsp_getSolcVersion::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getSolcVersion {
    fn clear(&mut self) {
        self.clear_ver();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getSolcVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getSolcVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_isSyncing {
    // message fields
    pub syncing: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_isSyncing {
    pub fn new() -> rsp_isSyncing {
        ::std::default::Default::default()
    }

    // bool syncing = 1;

    pub fn clear_syncing(&mut self) {
        self.syncing = false;
    }

    // Param is passed by value, moved
    pub fn set_syncing(&mut self, v: bool) {
        self.syncing = v;
    }

    pub fn get_syncing(&self) -> bool {
        self.syncing
    }
}

impl ::protobuf::Message for rsp_isSyncing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncing = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.syncing != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.syncing != false {
            os.write_bool(1, self.syncing)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_isSyncing {
        rsp_isSyncing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "syncing",
                    |m: &rsp_isSyncing| { &m.syncing },
                    |m: &mut rsp_isSyncing| { &mut m.syncing },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_isSyncing>(
                    "rsp_isSyncing",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_isSyncing {
        static mut instance: ::protobuf::lazy::Lazy<rsp_isSyncing> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_isSyncing,
        };
        unsafe {
            instance.get(rsp_isSyncing::new)
        }
    }
}

impl ::protobuf::Clear for rsp_isSyncing {
    fn clear(&mut self) {
        self.clear_syncing();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_isSyncing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_isSyncing {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_syncInfo {
    // message fields
    pub syncing: bool,
    pub networkBestBlock: u64,
    pub chainBestBlock: u64,
    pub maxImportBlocks: u32,
    pub startingBlock: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_syncInfo {
    pub fn new() -> rsp_syncInfo {
        ::std::default::Default::default()
    }

    // bool syncing = 1;

    pub fn clear_syncing(&mut self) {
        self.syncing = false;
    }

    // Param is passed by value, moved
    pub fn set_syncing(&mut self, v: bool) {
        self.syncing = v;
    }

    pub fn get_syncing(&self) -> bool {
        self.syncing
    }

    // uint64 networkBestBlock = 2;

    pub fn clear_networkBestBlock(&mut self) {
        self.networkBestBlock = 0;
    }

    // Param is passed by value, moved
    pub fn set_networkBestBlock(&mut self, v: u64) {
        self.networkBestBlock = v;
    }

    pub fn get_networkBestBlock(&self) -> u64 {
        self.networkBestBlock
    }

    // uint64 chainBestBlock = 3;

    pub fn clear_chainBestBlock(&mut self) {
        self.chainBestBlock = 0;
    }

    // Param is passed by value, moved
    pub fn set_chainBestBlock(&mut self, v: u64) {
        self.chainBestBlock = v;
    }

    pub fn get_chainBestBlock(&self) -> u64 {
        self.chainBestBlock
    }

    // uint32 maxImportBlocks = 4;

    pub fn clear_maxImportBlocks(&mut self) {
        self.maxImportBlocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_maxImportBlocks(&mut self, v: u32) {
        self.maxImportBlocks = v;
    }

    pub fn get_maxImportBlocks(&self) -> u32 {
        self.maxImportBlocks
    }

    // uint64 startingBlock = 5;

    pub fn clear_startingBlock(&mut self) {
        self.startingBlock = 0;
    }

    // Param is passed by value, moved
    pub fn set_startingBlock(&mut self, v: u64) {
        self.startingBlock = v;
    }

    pub fn get_startingBlock(&self) -> u64 {
        self.startingBlock
    }
}

impl ::protobuf::Message for rsp_syncInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.syncing = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.networkBestBlock = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chainBestBlock = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.maxImportBlocks = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.startingBlock = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.syncing != false {
            my_size += 2;
        }
        if self.networkBestBlock != 0 {
            my_size += ::protobuf::rt::value_size(2, self.networkBestBlock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.chainBestBlock != 0 {
            my_size += ::protobuf::rt::value_size(3, self.chainBestBlock, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maxImportBlocks != 0 {
            my_size += ::protobuf::rt::value_size(4, self.maxImportBlocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.startingBlock != 0 {
            my_size += ::protobuf::rt::value_size(5, self.startingBlock, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.syncing != false {
            os.write_bool(1, self.syncing)?;
        }
        if self.networkBestBlock != 0 {
            os.write_uint64(2, self.networkBestBlock)?;
        }
        if self.chainBestBlock != 0 {
            os.write_uint64(3, self.chainBestBlock)?;
        }
        if self.maxImportBlocks != 0 {
            os.write_uint32(4, self.maxImportBlocks)?;
        }
        if self.startingBlock != 0 {
            os.write_uint64(5, self.startingBlock)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_syncInfo {
        rsp_syncInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "syncing",
                    |m: &rsp_syncInfo| { &m.syncing },
                    |m: &mut rsp_syncInfo| { &mut m.syncing },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "networkBestBlock",
                    |m: &rsp_syncInfo| { &m.networkBestBlock },
                    |m: &mut rsp_syncInfo| { &mut m.networkBestBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "chainBestBlock",
                    |m: &rsp_syncInfo| { &m.chainBestBlock },
                    |m: &mut rsp_syncInfo| { &mut m.chainBestBlock },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "maxImportBlocks",
                    |m: &rsp_syncInfo| { &m.maxImportBlocks },
                    |m: &mut rsp_syncInfo| { &mut m.maxImportBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "startingBlock",
                    |m: &rsp_syncInfo| { &m.startingBlock },
                    |m: &mut rsp_syncInfo| { &mut m.startingBlock },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_syncInfo>(
                    "rsp_syncInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_syncInfo {
        static mut instance: ::protobuf::lazy::Lazy<rsp_syncInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_syncInfo,
        };
        unsafe {
            instance.get(rsp_syncInfo::new)
        }
    }
}

impl ::protobuf::Clear for rsp_syncInfo {
    fn clear(&mut self) {
        self.clear_syncing();
        self.clear_networkBestBlock();
        self.clear_chainBestBlock();
        self.clear_maxImportBlocks();
        self.clear_startingBlock();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_syncInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_syncInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_systemInfo {
    // message fields
    pub cpuUsage: f32,
    pub memoryUsage: u64,
    pub DBSize: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_systemInfo {
    pub fn new() -> rsp_systemInfo {
        ::std::default::Default::default()
    }

    // float cpuUsage = 1;

    pub fn clear_cpuUsage(&mut self) {
        self.cpuUsage = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cpuUsage(&mut self, v: f32) {
        self.cpuUsage = v;
    }

    pub fn get_cpuUsage(&self) -> f32 {
        self.cpuUsage
    }

    // uint64 memoryUsage = 2;

    pub fn clear_memoryUsage(&mut self) {
        self.memoryUsage = 0;
    }

    // Param is passed by value, moved
    pub fn set_memoryUsage(&mut self, v: u64) {
        self.memoryUsage = v;
    }

    pub fn get_memoryUsage(&self) -> u64 {
        self.memoryUsage
    }

    // uint64 DBSize = 3;

    pub fn clear_DBSize(&mut self) {
        self.DBSize = 0;
    }

    // Param is passed by value, moved
    pub fn set_DBSize(&mut self, v: u64) {
        self.DBSize = v;
    }

    pub fn get_DBSize(&self) -> u64 {
        self.DBSize
    }
}

impl ::protobuf::Message for rsp_systemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.cpuUsage = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.memoryUsage = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.DBSize = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpuUsage != 0. {
            my_size += 5;
        }
        if self.memoryUsage != 0 {
            my_size += ::protobuf::rt::value_size(2, self.memoryUsage, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DBSize != 0 {
            my_size += ::protobuf::rt::value_size(3, self.DBSize, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.cpuUsage != 0. {
            os.write_float(1, self.cpuUsage)?;
        }
        if self.memoryUsage != 0 {
            os.write_uint64(2, self.memoryUsage)?;
        }
        if self.DBSize != 0 {
            os.write_uint64(3, self.DBSize)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_systemInfo {
        rsp_systemInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "cpuUsage",
                    |m: &rsp_systemInfo| { &m.cpuUsage },
                    |m: &mut rsp_systemInfo| { &mut m.cpuUsage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "memoryUsage",
                    |m: &rsp_systemInfo| { &m.memoryUsage },
                    |m: &mut rsp_systemInfo| { &mut m.memoryUsage },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "DBSize",
                    |m: &rsp_systemInfo| { &m.DBSize },
                    |m: &mut rsp_systemInfo| { &mut m.DBSize },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_systemInfo>(
                    "rsp_systemInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_systemInfo {
        static mut instance: ::protobuf::lazy::Lazy<rsp_systemInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_systemInfo,
        };
        unsafe {
            instance.get(rsp_systemInfo::new)
        }
    }
}

impl ::protobuf::Clear for rsp_systemInfo {
    fn clear(&mut self) {
        self.clear_cpuUsage();
        self.clear_memoryUsage();
        self.clear_DBSize();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_systemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_systemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_eventRegister {
    // message fields
    pub events: ::protobuf::RepeatedField<::std::string::String>,
    pub filter: ::protobuf::SingularPtrField<t_FilterCt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_eventRegister {
    pub fn new() -> req_eventRegister {
        ::std::default::Default::default()
    }

    // repeated string events = 1;

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    pub fn get_events(&self) -> &[::std::string::String] {
        &self.events
    }

    // .bp_api.t_FilterCt filter = 2;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: t_FilterCt) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut t_FilterCt {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> t_FilterCt {
        self.filter.take().unwrap_or_else(|| t_FilterCt::new())
    }

    pub fn get_filter(&self) -> &t_FilterCt {
        self.filter.as_ref().unwrap_or_else(|| t_FilterCt::default_instance())
    }
}

impl ::protobuf::Message for req_eventRegister {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_eventRegister {
        req_eventRegister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "events",
                    |m: &req_eventRegister| { &m.events },
                    |m: &mut req_eventRegister| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_FilterCt>>(
                    "filter",
                    |m: &req_eventRegister| { &m.filter },
                    |m: &mut req_eventRegister| { &mut m.filter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_eventRegister>(
                    "req_eventRegister",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_eventRegister {
        static mut instance: ::protobuf::lazy::Lazy<req_eventRegister> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_eventRegister,
        };
        unsafe {
            instance.get(req_eventRegister::new)
        }
    }
}

impl ::protobuf::Clear for req_eventRegister {
    fn clear(&mut self) {
        self.clear_events();
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_eventRegister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_eventRegister {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_eventRegister {
    // message fields
    pub result: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_eventRegister {
    pub fn new() -> rsp_eventRegister {
        ::std::default::Default::default()
    }

    // bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }

    pub fn get_result(&self) -> bool {
        self.result
    }
}

impl ::protobuf::Message for rsp_eventRegister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_eventRegister {
        rsp_eventRegister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &rsp_eventRegister| { &m.result },
                    |m: &mut rsp_eventRegister| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_eventRegister>(
                    "rsp_eventRegister",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_eventRegister {
        static mut instance: ::protobuf::lazy::Lazy<rsp_eventRegister> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_eventRegister,
        };
        unsafe {
            instance.get(rsp_eventRegister::new)
        }
    }
}

impl ::protobuf::Clear for rsp_eventRegister {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_eventRegister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_eventRegister {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_eventDeregister {
    // message fields
    pub events: ::protobuf::RepeatedField<::std::string::String>,
    pub contractAddr: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_eventDeregister {
    pub fn new() -> req_eventDeregister {
        ::std::default::Default::default()
    }

    // repeated string events = 1;

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    pub fn get_events(&self) -> &[::std::string::String] {
        &self.events
    }

    // bytes contractAddr = 2;

    pub fn clear_contractAddr(&mut self) {
        self.contractAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.contractAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contractAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.contractAddr
    }

    // Take field
    pub fn take_contractAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.contractAddr, ::std::vec::Vec::new())
    }

    pub fn get_contractAddr(&self) -> &[u8] {
        &self.contractAddr
    }
}

impl ::protobuf::Message for req_eventDeregister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.contractAddr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.contractAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.contractAddr);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_string(1, &v)?;
        };
        if !self.contractAddr.is_empty() {
            os.write_bytes(2, &self.contractAddr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_eventDeregister {
        req_eventDeregister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "events",
                    |m: &req_eventDeregister| { &m.events },
                    |m: &mut req_eventDeregister| { &mut m.events },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "contractAddr",
                    |m: &req_eventDeregister| { &m.contractAddr },
                    |m: &mut req_eventDeregister| { &mut m.contractAddr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_eventDeregister>(
                    "req_eventDeregister",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_eventDeregister {
        static mut instance: ::protobuf::lazy::Lazy<req_eventDeregister> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_eventDeregister,
        };
        unsafe {
            instance.get(req_eventDeregister::new)
        }
    }
}

impl ::protobuf::Clear for req_eventDeregister {
    fn clear(&mut self) {
        self.clear_events();
        self.clear_contractAddr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_eventDeregister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_eventDeregister {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_eventDeregister {
    // message fields
    pub result: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_eventDeregister {
    pub fn new() -> rsp_eventDeregister {
        ::std::default::Default::default()
    }

    // bool result = 1;

    pub fn clear_result(&mut self) {
        self.result = false;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = v;
    }

    pub fn get_result(&self) -> bool {
        self.result
    }
}

impl ::protobuf::Message for rsp_eventDeregister {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.result = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.result != false {
            os.write_bool(1, self.result)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_eventDeregister {
        rsp_eventDeregister::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "result",
                    |m: &rsp_eventDeregister| { &m.result },
                    |m: &mut rsp_eventDeregister| { &mut m.result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_eventDeregister>(
                    "rsp_eventDeregister",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_eventDeregister {
        static mut instance: ::protobuf::lazy::Lazy<rsp_eventDeregister> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_eventDeregister,
        };
        unsafe {
            instance.get(rsp_eventDeregister::new)
        }
    }
}

impl ::protobuf::Clear for rsp_eventDeregister {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_eventDeregister {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_eventDeregister {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_EventCtCallback {
    // message fields
    pub ec: ::protobuf::RepeatedField<t_EventCt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_EventCtCallback {
    pub fn new() -> rsp_EventCtCallback {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_EventCt ec = 1;

    pub fn clear_ec(&mut self) {
        self.ec.clear();
    }

    // Param is passed by value, moved
    pub fn set_ec(&mut self, v: ::protobuf::RepeatedField<t_EventCt>) {
        self.ec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ec(&mut self) -> &mut ::protobuf::RepeatedField<t_EventCt> {
        &mut self.ec
    }

    // Take field
    pub fn take_ec(&mut self) -> ::protobuf::RepeatedField<t_EventCt> {
        ::std::mem::replace(&mut self.ec, ::protobuf::RepeatedField::new())
    }

    pub fn get_ec(&self) -> &[t_EventCt] {
        &self.ec
    }
}

impl ::protobuf::Message for rsp_EventCtCallback {
    fn is_initialized(&self) -> bool {
        for v in &self.ec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_EventCtCallback {
        rsp_EventCtCallback::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_EventCt>>(
                    "ec",
                    |m: &rsp_EventCtCallback| { &m.ec },
                    |m: &mut rsp_EventCtCallback| { &mut m.ec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_EventCtCallback>(
                    "rsp_EventCtCallback",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_EventCtCallback {
        static mut instance: ::protobuf::lazy::Lazy<rsp_EventCtCallback> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_EventCtCallback,
        };
        unsafe {
            instance.get(rsp_EventCtCallback::new)
        }
    }
}

impl ::protobuf::Clear for rsp_EventCtCallback {
    fn clear(&mut self) {
        self.clear_ec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_EventCtCallback {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_EventCtCallback {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_accountCreate {
    // message fields
    pub password: ::protobuf::RepeatedField<::std::string::String>,
    pub privateKey: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_accountCreate {
    pub fn new() -> req_accountCreate {
        ::std::default::Default::default()
    }

    // repeated string password = 1;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.password = v;
    }

    // Mutable pointer to the field.
    pub fn mut_password(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.password, ::protobuf::RepeatedField::new())
    }

    pub fn get_password(&self) -> &[::std::string::String] {
        &self.password
    }

    // bool privateKey = 2;

    pub fn clear_privateKey(&mut self) {
        self.privateKey = false;
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: bool) {
        self.privateKey = v;
    }

    pub fn get_privateKey(&self) -> bool {
        self.privateKey
    }
}

impl ::protobuf::Message for req_accountCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.password)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privateKey = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.password {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if self.privateKey != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.password {
            os.write_string(1, &v)?;
        };
        if self.privateKey != false {
            os.write_bool(2, self.privateKey)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_accountCreate {
        req_accountCreate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &req_accountCreate| { &m.password },
                    |m: &mut req_accountCreate| { &mut m.password },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "privateKey",
                    |m: &req_accountCreate| { &m.privateKey },
                    |m: &mut req_accountCreate| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_accountCreate>(
                    "req_accountCreate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_accountCreate {
        static mut instance: ::protobuf::lazy::Lazy<req_accountCreate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_accountCreate,
        };
        unsafe {
            instance.get(req_accountCreate::new)
        }
    }
}

impl ::protobuf::Clear for req_accountCreate {
    fn clear(&mut self) {
        self.clear_password();
        self.clear_privateKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_accountCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_accountCreate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_accountCreate {
    // message fields
    pub address: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub privateKey: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_accountCreate {
    pub fn new() -> rsp_accountCreate {
        ::std::default::Default::default()
    }

    // repeated bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.address, ::protobuf::RepeatedField::new())
    }

    pub fn get_address(&self) -> &[::std::vec::Vec<u8>] {
        &self.address
    }

    // repeated bytes privateKey = 2;

    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    pub fn mut_privateKey(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.privateKey, ::protobuf::RepeatedField::new())
    }

    pub fn get_privateKey(&self) -> &[::std::vec::Vec<u8>] {
        &self.privateKey
    }
}

impl ::protobuf::Message for rsp_accountCreate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.privateKey {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address {
            os.write_bytes(1, &v)?;
        };
        for v in &self.privateKey {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_accountCreate {
        rsp_accountCreate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &rsp_accountCreate| { &m.address },
                    |m: &mut rsp_accountCreate| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "privateKey",
                    |m: &rsp_accountCreate| { &m.privateKey },
                    |m: &mut rsp_accountCreate| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_accountCreate>(
                    "rsp_accountCreate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_accountCreate {
        static mut instance: ::protobuf::lazy::Lazy<rsp_accountCreate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_accountCreate,
        };
        unsafe {
            instance.get(rsp_accountCreate::new)
        }
    }
}

impl ::protobuf::Clear for rsp_accountCreate {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_privateKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_accountCreate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_accountCreate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_accountlock {
    // message fields
    pub account: ::std::vec::Vec<u8>,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_accountlock {
    pub fn new() -> req_accountlock {
        ::std::default::Default::default()
    }

    // bytes account = 1;

    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::vec::Vec<u8>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.account, ::std::vec::Vec::new())
    }

    pub fn get_account(&self) -> &[u8] {
        &self.account
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for req_accountlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.account)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.account);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.account.is_empty() {
            os.write_bytes(1, &self.account)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_accountlock {
        req_accountlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "account",
                    |m: &req_accountlock| { &m.account },
                    |m: &mut req_accountlock| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &req_accountlock| { &m.password },
                    |m: &mut req_accountlock| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_accountlock>(
                    "req_accountlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_accountlock {
        static mut instance: ::protobuf::lazy::Lazy<req_accountlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_accountlock,
        };
        unsafe {
            instance.get(req_accountlock::new)
        }
    }
}

impl ::protobuf::Clear for req_accountlock {
    fn clear(&mut self) {
        self.clear_account();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_accountlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_accountlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_accountlock {
    // message fields
    pub locked: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_accountlock {
    pub fn new() -> rsp_accountlock {
        ::std::default::Default::default()
    }

    // bool locked = 1;

    pub fn clear_locked(&mut self) {
        self.locked = false;
    }

    // Param is passed by value, moved
    pub fn set_locked(&mut self, v: bool) {
        self.locked = v;
    }

    pub fn get_locked(&self) -> bool {
        self.locked
    }
}

impl ::protobuf::Message for rsp_accountlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.locked = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.locked != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.locked != false {
            os.write_bool(1, self.locked)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_accountlock {
        rsp_accountlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "locked",
                    |m: &rsp_accountlock| { &m.locked },
                    |m: &mut rsp_accountlock| { &mut m.locked },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_accountlock>(
                    "rsp_accountlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_accountlock {
        static mut instance: ::protobuf::lazy::Lazy<rsp_accountlock> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_accountlock,
        };
        unsafe {
            instance.get(rsp_accountlock::new)
        }
    }
}

impl ::protobuf::Clear for rsp_accountlock {
    fn clear(&mut self) {
        self.clear_locked();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_accountlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_accountlock {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_userPrivilege {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_userPrivilege {
    pub fn new() -> req_userPrivilege {
        ::std::default::Default::default()
    }

    // string username = 1;

    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    pub fn get_username(&self) -> &str {
        &self.username
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for req_userPrivilege {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_userPrivilege {
        req_userPrivilege::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "username",
                    |m: &req_userPrivilege| { &m.username },
                    |m: &mut req_userPrivilege| { &mut m.username },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &req_userPrivilege| { &m.password },
                    |m: &mut req_userPrivilege| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_userPrivilege>(
                    "req_userPrivilege",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_userPrivilege {
        static mut instance: ::protobuf::lazy::Lazy<req_userPrivilege> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_userPrivilege,
        };
        unsafe {
            instance.get(req_userPrivilege::new)
        }
    }
}

impl ::protobuf::Clear for req_userPrivilege {
    fn clear(&mut self) {
        self.clear_username();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_userPrivilege {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_userPrivilege {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_userPrivilege {
    // message fields
    pub privilege: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_userPrivilege {
    pub fn new() -> rsp_userPrivilege {
        ::std::default::Default::default()
    }

    // repeated string privilege = 1;

    pub fn clear_privilege(&mut self) {
        self.privilege.clear();
    }

    // Param is passed by value, moved
    pub fn set_privilege(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.privilege = v;
    }

    // Mutable pointer to the field.
    pub fn mut_privilege(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.privilege
    }

    // Take field
    pub fn take_privilege(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.privilege, ::protobuf::RepeatedField::new())
    }

    pub fn get_privilege(&self) -> &[::std::string::String] {
        &self.privilege
    }
}

impl ::protobuf::Message for rsp_userPrivilege {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.privilege)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.privilege {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.privilege {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_userPrivilege {
        rsp_userPrivilege::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "privilege",
                    |m: &rsp_userPrivilege| { &m.privilege },
                    |m: &mut rsp_userPrivilege| { &mut m.privilege },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_userPrivilege>(
                    "rsp_userPrivilege",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_userPrivilege {
        static mut instance: ::protobuf::lazy::Lazy<rsp_userPrivilege> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_userPrivilege,
        };
        unsafe {
            instance.get(rsp_userPrivilege::new)
        }
    }
}

impl ::protobuf::Clear for rsp_userPrivilege {
    fn clear(&mut self) {
        self.clear_privilege();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_userPrivilege {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_userPrivilege {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_queryCtEvents {
    // message fields
    pub filter: ::protobuf::SingularPtrField<t_FilterCt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_queryCtEvents {
    pub fn new() -> req_queryCtEvents {
        ::std::default::Default::default()
    }

    // .bp_api.t_FilterCt filter = 1;

    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: t_FilterCt) {
        self.filter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut t_FilterCt {
        if self.filter.is_none() {
            self.filter.set_default();
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> t_FilterCt {
        self.filter.take().unwrap_or_else(|| t_FilterCt::new())
    }

    pub fn get_filter(&self) -> &t_FilterCt {
        self.filter.as_ref().unwrap_or_else(|| t_FilterCt::default_instance())
    }
}

impl ::protobuf::Message for req_queryCtEvents {
    fn is_initialized(&self) -> bool {
        for v in &self.filter {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.filter.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_queryCtEvents {
        req_queryCtEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_FilterCt>>(
                    "filter",
                    |m: &req_queryCtEvents| { &m.filter },
                    |m: &mut req_queryCtEvents| { &mut m.filter },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_queryCtEvents>(
                    "req_queryCtEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_queryCtEvents {
        static mut instance: ::protobuf::lazy::Lazy<req_queryCtEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_queryCtEvents,
        };
        unsafe {
            instance.get(req_queryCtEvents::new)
        }
    }
}

impl ::protobuf::Clear for req_queryCtEvents {
    fn clear(&mut self) {
        self.clear_filter();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_queryCtEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_queryCtEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_queryCtEvents {
    // message fields
    pub ec: ::protobuf::RepeatedField<t_EventCt>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_queryCtEvents {
    pub fn new() -> rsp_queryCtEvents {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_EventCt ec = 1;

    pub fn clear_ec(&mut self) {
        self.ec.clear();
    }

    // Param is passed by value, moved
    pub fn set_ec(&mut self, v: ::protobuf::RepeatedField<t_EventCt>) {
        self.ec = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ec(&mut self) -> &mut ::protobuf::RepeatedField<t_EventCt> {
        &mut self.ec
    }

    // Take field
    pub fn take_ec(&mut self) -> ::protobuf::RepeatedField<t_EventCt> {
        ::std::mem::replace(&mut self.ec, ::protobuf::RepeatedField::new())
    }

    pub fn get_ec(&self) -> &[t_EventCt] {
        &self.ec
    }
}

impl ::protobuf::Message for rsp_queryCtEvents {
    fn is_initialized(&self) -> bool {
        for v in &self.ec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ec {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ec {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_queryCtEvents {
        rsp_queryCtEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_EventCt>>(
                    "ec",
                    |m: &rsp_queryCtEvents| { &m.ec },
                    |m: &mut rsp_queryCtEvents| { &mut m.ec },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_queryCtEvents>(
                    "rsp_queryCtEvents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_queryCtEvents {
        static mut instance: ::protobuf::lazy::Lazy<rsp_queryCtEvents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_queryCtEvents,
        };
        unsafe {
            instance.get(rsp_queryCtEvents::new)
        }
    }
}

impl ::protobuf::Clear for rsp_queryCtEvents {
    fn clear(&mut self) {
        self.clear_ec();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_queryCtEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_queryCtEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_PrivateKey {
    // message fields
    pub privateKey: ::std::string::String,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_PrivateKey {
    pub fn new() -> t_PrivateKey {
        ::std::default::Default::default()
    }

    // string privateKey = 1;

    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::std::string::String) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateKey(&mut self) -> &mut ::std::string::String {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.privateKey, ::std::string::String::new())
    }

    pub fn get_privateKey(&self) -> &str {
        &self.privateKey
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for t_PrivateKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.privateKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.privateKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.privateKey);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.privateKey.is_empty() {
            os.write_string(1, &self.privateKey)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_PrivateKey {
        t_PrivateKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "privateKey",
                    |m: &t_PrivateKey| { &m.privateKey },
                    |m: &mut t_PrivateKey| { &mut m.privateKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &t_PrivateKey| { &m.password },
                    |m: &mut t_PrivateKey| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_PrivateKey>(
                    "t_PrivateKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_PrivateKey {
        static mut instance: ::protobuf::lazy::Lazy<t_PrivateKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_PrivateKey,
        };
        unsafe {
            instance.get(t_PrivateKey::new)
        }
    }
}

impl ::protobuf::Clear for t_PrivateKey {
    fn clear(&mut self) {
        self.clear_privateKey();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_PrivateKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_PrivateKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_importAccounts {
    // message fields
    pub privateKey: ::protobuf::RepeatedField<t_PrivateKey>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_importAccounts {
    pub fn new() -> req_importAccounts {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_PrivateKey privateKey = 1;

    pub fn clear_privateKey(&mut self) {
        self.privateKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_privateKey(&mut self, v: ::protobuf::RepeatedField<t_PrivateKey>) {
        self.privateKey = v;
    }

    // Mutable pointer to the field.
    pub fn mut_privateKey(&mut self) -> &mut ::protobuf::RepeatedField<t_PrivateKey> {
        &mut self.privateKey
    }

    // Take field
    pub fn take_privateKey(&mut self) -> ::protobuf::RepeatedField<t_PrivateKey> {
        ::std::mem::replace(&mut self.privateKey, ::protobuf::RepeatedField::new())
    }

    pub fn get_privateKey(&self) -> &[t_PrivateKey] {
        &self.privateKey
    }
}

impl ::protobuf::Message for req_importAccounts {
    fn is_initialized(&self) -> bool {
        for v in &self.privateKey {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.privateKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.privateKey {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.privateKey {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_importAccounts {
        req_importAccounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_PrivateKey>>(
                    "privateKey",
                    |m: &req_importAccounts| { &m.privateKey },
                    |m: &mut req_importAccounts| { &mut m.privateKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_importAccounts>(
                    "req_importAccounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_importAccounts {
        static mut instance: ::protobuf::lazy::Lazy<req_importAccounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_importAccounts,
        };
        unsafe {
            instance.get(req_importAccounts::new)
        }
    }
}

impl ::protobuf::Clear for req_importAccounts {
    fn clear(&mut self) {
        self.clear_privateKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_importAccounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_importAccounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_importAccounts {
    // message fields
    pub invalidKey: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_importAccounts {
    pub fn new() -> rsp_importAccounts {
        ::std::default::Default::default()
    }

    // repeated string invalidKey = 1;

    pub fn clear_invalidKey(&mut self) {
        self.invalidKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_invalidKey(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.invalidKey = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invalidKey(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.invalidKey
    }

    // Take field
    pub fn take_invalidKey(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.invalidKey, ::protobuf::RepeatedField::new())
    }

    pub fn get_invalidKey(&self) -> &[::std::string::String] {
        &self.invalidKey
    }
}

impl ::protobuf::Message for rsp_importAccounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.invalidKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.invalidKey {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.invalidKey {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_importAccounts {
        rsp_importAccounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "invalidKey",
                    |m: &rsp_importAccounts| { &m.invalidKey },
                    |m: &mut rsp_importAccounts| { &mut m.invalidKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_importAccounts>(
                    "rsp_importAccounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_importAccounts {
        static mut instance: ::protobuf::lazy::Lazy<rsp_importAccounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_importAccounts,
        };
        unsafe {
            instance.get(rsp_importAccounts::new)
        }
    }
}

impl ::protobuf::Clear for rsp_importAccounts {
    fn clear(&mut self) {
        self.clear_invalidKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_importAccounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_importAccounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct t_Key {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    pub password: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl t_Key {
    pub fn new() -> t_Key {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }

    // string password = 2;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    pub fn get_password(&self) -> &str {
        &self.password
    }
}

impl ::protobuf::Message for t_Key {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> t_Key {
        t_Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &t_Key| { &m.address },
                    |m: &mut t_Key| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "password",
                    |m: &t_Key| { &m.password },
                    |m: &mut t_Key| { &mut m.password },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<t_Key>(
                    "t_Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static t_Key {
        static mut instance: ::protobuf::lazy::Lazy<t_Key> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const t_Key,
        };
        unsafe {
            instance.get(t_Key::new)
        }
    }
}

impl ::protobuf::Clear for t_Key {
    fn clear(&mut self) {
        self.clear_address();
        self.clear_password();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for t_Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for t_Key {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_exportAccounts {
    // message fields
    pub keyFile: ::protobuf::RepeatedField<t_Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_exportAccounts {
    pub fn new() -> req_exportAccounts {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_Key keyFile = 1;

    pub fn clear_keyFile(&mut self) {
        self.keyFile.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyFile(&mut self, v: ::protobuf::RepeatedField<t_Key>) {
        self.keyFile = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyFile(&mut self) -> &mut ::protobuf::RepeatedField<t_Key> {
        &mut self.keyFile
    }

    // Take field
    pub fn take_keyFile(&mut self) -> ::protobuf::RepeatedField<t_Key> {
        ::std::mem::replace(&mut self.keyFile, ::protobuf::RepeatedField::new())
    }

    pub fn get_keyFile(&self) -> &[t_Key] {
        &self.keyFile
    }
}

impl ::protobuf::Message for req_exportAccounts {
    fn is_initialized(&self) -> bool {
        for v in &self.keyFile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keyFile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keyFile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keyFile {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_exportAccounts {
        req_exportAccounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_Key>>(
                    "keyFile",
                    |m: &req_exportAccounts| { &m.keyFile },
                    |m: &mut req_exportAccounts| { &mut m.keyFile },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_exportAccounts>(
                    "req_exportAccounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_exportAccounts {
        static mut instance: ::protobuf::lazy::Lazy<req_exportAccounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_exportAccounts,
        };
        unsafe {
            instance.get(req_exportAccounts::new)
        }
    }
}

impl ::protobuf::Clear for req_exportAccounts {
    fn clear(&mut self) {
        self.clear_keyFile();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_exportAccounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_exportAccounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_exportAccounts {
    // message fields
    pub keyFile: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub failedKey: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_exportAccounts {
    pub fn new() -> rsp_exportAccounts {
        ::std::default::Default::default()
    }

    // repeated bytes keyFile = 1;

    pub fn clear_keyFile(&mut self) {
        self.keyFile.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyFile(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.keyFile = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyFile(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.keyFile
    }

    // Take field
    pub fn take_keyFile(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.keyFile, ::protobuf::RepeatedField::new())
    }

    pub fn get_keyFile(&self) -> &[::std::vec::Vec<u8>] {
        &self.keyFile
    }

    // repeated bytes failedKey = 2;

    pub fn clear_failedKey(&mut self) {
        self.failedKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_failedKey(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.failedKey = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failedKey(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.failedKey
    }

    // Take field
    pub fn take_failedKey(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.failedKey, ::protobuf::RepeatedField::new())
    }

    pub fn get_failedKey(&self) -> &[::std::vec::Vec<u8>] {
        &self.failedKey
    }
}

impl ::protobuf::Message for rsp_exportAccounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.keyFile)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.failedKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keyFile {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in &self.failedKey {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keyFile {
            os.write_bytes(1, &v)?;
        };
        for v in &self.failedKey {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_exportAccounts {
        rsp_exportAccounts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "keyFile",
                    |m: &rsp_exportAccounts| { &m.keyFile },
                    |m: &mut rsp_exportAccounts| { &mut m.keyFile },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "failedKey",
                    |m: &rsp_exportAccounts| { &m.failedKey },
                    |m: &mut rsp_exportAccounts| { &mut m.failedKey },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_exportAccounts>(
                    "rsp_exportAccounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_exportAccounts {
        static mut instance: ::protobuf::lazy::Lazy<rsp_exportAccounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_exportAccounts,
        };
        unsafe {
            instance.get(rsp_exportAccounts::new)
        }
    }
}

impl ::protobuf::Clear for rsp_exportAccounts {
    fn clear(&mut self) {
        self.clear_keyFile();
        self.clear_failedKey();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_exportAccounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_exportAccounts {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getCurrentTotalDifficulty {
    // message fields
    pub totalDiff: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getCurrentTotalDifficulty {
    pub fn new() -> rsp_getCurrentTotalDifficulty {
        ::std::default::Default::default()
    }

    // bytes totalDiff = 1;

    pub fn clear_totalDiff(&mut self) {
        self.totalDiff.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalDiff(&mut self, v: ::std::vec::Vec<u8>) {
        self.totalDiff = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalDiff(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.totalDiff
    }

    // Take field
    pub fn take_totalDiff(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.totalDiff, ::std::vec::Vec::new())
    }

    pub fn get_totalDiff(&self) -> &[u8] {
        &self.totalDiff
    }
}

impl ::protobuf::Message for rsp_getCurrentTotalDifficulty {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.totalDiff)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.totalDiff.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.totalDiff);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.totalDiff.is_empty() {
            os.write_bytes(1, &self.totalDiff)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getCurrentTotalDifficulty {
        rsp_getCurrentTotalDifficulty::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "totalDiff",
                    |m: &rsp_getCurrentTotalDifficulty| { &m.totalDiff },
                    |m: &mut rsp_getCurrentTotalDifficulty| { &mut m.totalDiff },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getCurrentTotalDifficulty>(
                    "rsp_getCurrentTotalDifficulty",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getCurrentTotalDifficulty {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getCurrentTotalDifficulty> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getCurrentTotalDifficulty,
        };
        unsafe {
            instance.get(rsp_getCurrentTotalDifficulty::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getCurrentTotalDifficulty {
    fn clear(&mut self) {
        self.clear_totalDiff();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getCurrentTotalDifficulty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getCurrentTotalDifficulty {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockDetailsByNumber {
    // message fields
    pub blkNumbers: ::std::vec::Vec<u64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockDetailsByNumber {
    pub fn new() -> req_getBlockDetailsByNumber {
        ::std::default::Default::default()
    }

    // repeated uint64 blkNumbers = 1;

    pub fn clear_blkNumbers(&mut self) {
        self.blkNumbers.clear();
    }

    // Param is passed by value, moved
    pub fn set_blkNumbers(&mut self, v: ::std::vec::Vec<u64>) {
        self.blkNumbers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blkNumbers(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.blkNumbers
    }

    // Take field
    pub fn take_blkNumbers(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.blkNumbers, ::std::vec::Vec::new())
    }

    pub fn get_blkNumbers(&self) -> &[u64] {
        &self.blkNumbers
    }
}

impl ::protobuf::Message for req_getBlockDetailsByNumber {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.blkNumbers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blkNumbers {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blkNumbers {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockDetailsByNumber {
        req_getBlockDetailsByNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blkNumbers",
                    |m: &req_getBlockDetailsByNumber| { &m.blkNumbers },
                    |m: &mut req_getBlockDetailsByNumber| { &mut m.blkNumbers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockDetailsByNumber>(
                    "req_getBlockDetailsByNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockDetailsByNumber {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockDetailsByNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockDetailsByNumber,
        };
        unsafe {
            instance.get(req_getBlockDetailsByNumber::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockDetailsByNumber {
    fn clear(&mut self) {
        self.clear_blkNumbers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockDetailsByNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockDetailsByNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockDetailsByNumber {
    // message fields
    pub blkDetails: ::protobuf::RepeatedField<t_BlockDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockDetailsByNumber {
    pub fn new() -> rsp_getBlockDetailsByNumber {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_BlockDetail blkDetails = 1;

    pub fn clear_blkDetails(&mut self) {
        self.blkDetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_blkDetails(&mut self, v: ::protobuf::RepeatedField<t_BlockDetail>) {
        self.blkDetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blkDetails(&mut self) -> &mut ::protobuf::RepeatedField<t_BlockDetail> {
        &mut self.blkDetails
    }

    // Take field
    pub fn take_blkDetails(&mut self) -> ::protobuf::RepeatedField<t_BlockDetail> {
        ::std::mem::replace(&mut self.blkDetails, ::protobuf::RepeatedField::new())
    }

    pub fn get_blkDetails(&self) -> &[t_BlockDetail] {
        &self.blkDetails
    }
}

impl ::protobuf::Message for rsp_getBlockDetailsByNumber {
    fn is_initialized(&self) -> bool {
        for v in &self.blkDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blkDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blkDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blkDetails {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockDetailsByNumber {
        rsp_getBlockDetailsByNumber::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_BlockDetail>>(
                    "blkDetails",
                    |m: &rsp_getBlockDetailsByNumber| { &m.blkDetails },
                    |m: &mut rsp_getBlockDetailsByNumber| { &mut m.blkDetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockDetailsByNumber>(
                    "rsp_getBlockDetailsByNumber",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockDetailsByNumber {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockDetailsByNumber> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockDetailsByNumber,
        };
        unsafe {
            instance.get(rsp_getBlockDetailsByNumber::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockDetailsByNumber {
    fn clear(&mut self) {
        self.clear_blkDetails();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockDetailsByNumber {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockDetailsByNumber {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockDetailsByLatest {
    // message fields
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockDetailsByLatest {
    pub fn new() -> req_getBlockDetailsByLatest {
        ::std::default::Default::default()
    }

    // uint64 count = 1;

    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    pub fn get_count(&self) -> u64 {
        self.count
    }
}

impl ::protobuf::Message for req_getBlockDetailsByLatest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockDetailsByLatest {
        req_getBlockDetailsByLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "count",
                    |m: &req_getBlockDetailsByLatest| { &m.count },
                    |m: &mut req_getBlockDetailsByLatest| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockDetailsByLatest>(
                    "req_getBlockDetailsByLatest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockDetailsByLatest {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockDetailsByLatest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockDetailsByLatest,
        };
        unsafe {
            instance.get(req_getBlockDetailsByLatest::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockDetailsByLatest {
    fn clear(&mut self) {
        self.clear_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockDetailsByLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockDetailsByLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockDetailsByLatest {
    // message fields
    pub blkDetails: ::protobuf::RepeatedField<t_BlockDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockDetailsByLatest {
    pub fn new() -> rsp_getBlockDetailsByLatest {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_BlockDetail blkDetails = 1;

    pub fn clear_blkDetails(&mut self) {
        self.blkDetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_blkDetails(&mut self, v: ::protobuf::RepeatedField<t_BlockDetail>) {
        self.blkDetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blkDetails(&mut self) -> &mut ::protobuf::RepeatedField<t_BlockDetail> {
        &mut self.blkDetails
    }

    // Take field
    pub fn take_blkDetails(&mut self) -> ::protobuf::RepeatedField<t_BlockDetail> {
        ::std::mem::replace(&mut self.blkDetails, ::protobuf::RepeatedField::new())
    }

    pub fn get_blkDetails(&self) -> &[t_BlockDetail] {
        &self.blkDetails
    }
}

impl ::protobuf::Message for rsp_getBlockDetailsByLatest {
    fn is_initialized(&self) -> bool {
        for v in &self.blkDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blkDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blkDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blkDetails {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockDetailsByLatest {
        rsp_getBlockDetailsByLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_BlockDetail>>(
                    "blkDetails",
                    |m: &rsp_getBlockDetailsByLatest| { &m.blkDetails },
                    |m: &mut rsp_getBlockDetailsByLatest| { &mut m.blkDetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockDetailsByLatest>(
                    "rsp_getBlockDetailsByLatest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockDetailsByLatest {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockDetailsByLatest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockDetailsByLatest,
        };
        unsafe {
            instance.get(rsp_getBlockDetailsByLatest::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockDetailsByLatest {
    fn clear(&mut self) {
        self.clear_blkDetails();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockDetailsByLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockDetailsByLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlocksByLatest {
    // message fields
    pub count: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlocksByLatest {
    pub fn new() -> req_getBlocksByLatest {
        ::std::default::Default::default()
    }

    // uint64 count = 1;

    pub fn clear_count(&mut self) {
        self.count = 0;
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u64) {
        self.count = v;
    }

    pub fn get_count(&self) -> u64 {
        self.count
    }
}

impl ::protobuf::Message for req_getBlocksByLatest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.count != 0 {
            os.write_uint64(1, self.count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlocksByLatest {
        req_getBlocksByLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "count",
                    |m: &req_getBlocksByLatest| { &m.count },
                    |m: &mut req_getBlocksByLatest| { &mut m.count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlocksByLatest>(
                    "req_getBlocksByLatest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlocksByLatest {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlocksByLatest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlocksByLatest,
        };
        unsafe {
            instance.get(req_getBlocksByLatest::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlocksByLatest {
    fn clear(&mut self) {
        self.clear_count();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlocksByLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlocksByLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlocksByLatest {
    // message fields
    pub blks: ::protobuf::RepeatedField<t_Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlocksByLatest {
    pub fn new() -> rsp_getBlocksByLatest {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_Block blks = 1;

    pub fn clear_blks(&mut self) {
        self.blks.clear();
    }

    // Param is passed by value, moved
    pub fn set_blks(&mut self, v: ::protobuf::RepeatedField<t_Block>) {
        self.blks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blks(&mut self) -> &mut ::protobuf::RepeatedField<t_Block> {
        &mut self.blks
    }

    // Take field
    pub fn take_blks(&mut self) -> ::protobuf::RepeatedField<t_Block> {
        ::std::mem::replace(&mut self.blks, ::protobuf::RepeatedField::new())
    }

    pub fn get_blks(&self) -> &[t_Block] {
        &self.blks
    }
}

impl ::protobuf::Message for rsp_getBlocksByLatest {
    fn is_initialized(&self) -> bool {
        for v in &self.blks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlocksByLatest {
        rsp_getBlocksByLatest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_Block>>(
                    "blks",
                    |m: &rsp_getBlocksByLatest| { &m.blks },
                    |m: &mut rsp_getBlocksByLatest| { &mut m.blks },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlocksByLatest>(
                    "rsp_getBlocksByLatest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlocksByLatest {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlocksByLatest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlocksByLatest,
        };
        unsafe {
            instance.get(rsp_getBlocksByLatest::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlocksByLatest {
    fn clear(&mut self) {
        self.clear_blks();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlocksByLatest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlocksByLatest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getAccountDetailsByAddressList {
    // message fields
    pub addresses: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getAccountDetailsByAddressList {
    pub fn new() -> req_getAccountDetailsByAddressList {
        ::std::default::Default::default()
    }

    // repeated bytes addresses = 1;

    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    pub fn get_addresses(&self) -> &[::std::vec::Vec<u8>] {
        &self.addresses
    }
}

impl ::protobuf::Message for req_getAccountDetailsByAddressList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.addresses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_bytes(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getAccountDetailsByAddressList {
        req_getAccountDetailsByAddressList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "addresses",
                    |m: &req_getAccountDetailsByAddressList| { &m.addresses },
                    |m: &mut req_getAccountDetailsByAddressList| { &mut m.addresses },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getAccountDetailsByAddressList>(
                    "req_getAccountDetailsByAddressList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getAccountDetailsByAddressList {
        static mut instance: ::protobuf::lazy::Lazy<req_getAccountDetailsByAddressList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getAccountDetailsByAddressList,
        };
        unsafe {
            instance.get(req_getAccountDetailsByAddressList::new)
        }
    }
}

impl ::protobuf::Clear for req_getAccountDetailsByAddressList {
    fn clear(&mut self) {
        self.clear_addresses();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getAccountDetailsByAddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getAccountDetailsByAddressList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getAccountDetailsByAddressList {
    // message fields
    pub accounts: ::protobuf::RepeatedField<t_AccountDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getAccountDetailsByAddressList {
    pub fn new() -> rsp_getAccountDetailsByAddressList {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_AccountDetail accounts = 1;

    pub fn clear_accounts(&mut self) {
        self.accounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts(&mut self, v: ::protobuf::RepeatedField<t_AccountDetail>) {
        self.accounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts(&mut self) -> &mut ::protobuf::RepeatedField<t_AccountDetail> {
        &mut self.accounts
    }

    // Take field
    pub fn take_accounts(&mut self) -> ::protobuf::RepeatedField<t_AccountDetail> {
        ::std::mem::replace(&mut self.accounts, ::protobuf::RepeatedField::new())
    }

    pub fn get_accounts(&self) -> &[t_AccountDetail] {
        &self.accounts
    }
}

impl ::protobuf::Message for rsp_getAccountDetailsByAddressList {
    fn is_initialized(&self) -> bool {
        for v in &self.accounts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accounts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accounts {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getAccountDetailsByAddressList {
        rsp_getAccountDetailsByAddressList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_AccountDetail>>(
                    "accounts",
                    |m: &rsp_getAccountDetailsByAddressList| { &m.accounts },
                    |m: &mut rsp_getAccountDetailsByAddressList| { &mut m.accounts },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getAccountDetailsByAddressList>(
                    "rsp_getAccountDetailsByAddressList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getAccountDetailsByAddressList {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getAccountDetailsByAddressList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getAccountDetailsByAddressList,
        };
        unsafe {
            instance.get(rsp_getAccountDetailsByAddressList::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getAccountDetailsByAddressList {
    fn clear(&mut self) {
        self.clear_accounts();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getAccountDetailsByAddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getAccountDetailsByAddressList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockSqlByRange {
    // message fields
    pub blkNumberStart: u64,
    pub blkNumberEnd: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockSqlByRange {
    pub fn new() -> req_getBlockSqlByRange {
        ::std::default::Default::default()
    }

    // uint64 blkNumberStart = 1;

    pub fn clear_blkNumberStart(&mut self) {
        self.blkNumberStart = 0;
    }

    // Param is passed by value, moved
    pub fn set_blkNumberStart(&mut self, v: u64) {
        self.blkNumberStart = v;
    }

    pub fn get_blkNumberStart(&self) -> u64 {
        self.blkNumberStart
    }

    // uint64 blkNumberEnd = 2;

    pub fn clear_blkNumberEnd(&mut self) {
        self.blkNumberEnd = 0;
    }

    // Param is passed by value, moved
    pub fn set_blkNumberEnd(&mut self, v: u64) {
        self.blkNumberEnd = v;
    }

    pub fn get_blkNumberEnd(&self) -> u64 {
        self.blkNumberEnd
    }
}

impl ::protobuf::Message for req_getBlockSqlByRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blkNumberStart = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blkNumberEnd = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blkNumberStart != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blkNumberStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blkNumberEnd != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blkNumberEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blkNumberStart != 0 {
            os.write_uint64(1, self.blkNumberStart)?;
        }
        if self.blkNumberEnd != 0 {
            os.write_uint64(2, self.blkNumberEnd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockSqlByRange {
        req_getBlockSqlByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blkNumberStart",
                    |m: &req_getBlockSqlByRange| { &m.blkNumberStart },
                    |m: &mut req_getBlockSqlByRange| { &mut m.blkNumberStart },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blkNumberEnd",
                    |m: &req_getBlockSqlByRange| { &m.blkNumberEnd },
                    |m: &mut req_getBlockSqlByRange| { &mut m.blkNumberEnd },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockSqlByRange>(
                    "req_getBlockSqlByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockSqlByRange {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockSqlByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockSqlByRange,
        };
        unsafe {
            instance.get(req_getBlockSqlByRange::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockSqlByRange {
    fn clear(&mut self) {
        self.clear_blkNumberStart();
        self.clear_blkNumberEnd();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockSqlByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockSqlByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockSqlByRange {
    // message fields
    pub blkSql: ::protobuf::RepeatedField<t_BlockSql>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockSqlByRange {
    pub fn new() -> rsp_getBlockSqlByRange {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_BlockSql blkSql = 1;

    pub fn clear_blkSql(&mut self) {
        self.blkSql.clear();
    }

    // Param is passed by value, moved
    pub fn set_blkSql(&mut self, v: ::protobuf::RepeatedField<t_BlockSql>) {
        self.blkSql = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blkSql(&mut self) -> &mut ::protobuf::RepeatedField<t_BlockSql> {
        &mut self.blkSql
    }

    // Take field
    pub fn take_blkSql(&mut self) -> ::protobuf::RepeatedField<t_BlockSql> {
        ::std::mem::replace(&mut self.blkSql, ::protobuf::RepeatedField::new())
    }

    pub fn get_blkSql(&self) -> &[t_BlockSql] {
        &self.blkSql
    }
}

impl ::protobuf::Message for rsp_getBlockSqlByRange {
    fn is_initialized(&self) -> bool {
        for v in &self.blkSql {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blkSql)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blkSql {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blkSql {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockSqlByRange {
        rsp_getBlockSqlByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_BlockSql>>(
                    "blkSql",
                    |m: &rsp_getBlockSqlByRange| { &m.blkSql },
                    |m: &mut rsp_getBlockSqlByRange| { &mut m.blkSql },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockSqlByRange>(
                    "rsp_getBlockSqlByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockSqlByRange {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockSqlByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockSqlByRange,
        };
        unsafe {
            instance.get(rsp_getBlockSqlByRange::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockSqlByRange {
    fn clear(&mut self) {
        self.clear_blkSql();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockSqlByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockSqlByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockDetailsByRange {
    // message fields
    pub blkNumberStart: u64,
    pub blkNumberEnd: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockDetailsByRange {
    pub fn new() -> req_getBlockDetailsByRange {
        ::std::default::Default::default()
    }

    // uint64 blkNumberStart = 1;

    pub fn clear_blkNumberStart(&mut self) {
        self.blkNumberStart = 0;
    }

    // Param is passed by value, moved
    pub fn set_blkNumberStart(&mut self, v: u64) {
        self.blkNumberStart = v;
    }

    pub fn get_blkNumberStart(&self) -> u64 {
        self.blkNumberStart
    }

    // uint64 blkNumberEnd = 2;

    pub fn clear_blkNumberEnd(&mut self) {
        self.blkNumberEnd = 0;
    }

    // Param is passed by value, moved
    pub fn set_blkNumberEnd(&mut self, v: u64) {
        self.blkNumberEnd = v;
    }

    pub fn get_blkNumberEnd(&self) -> u64 {
        self.blkNumberEnd
    }
}

impl ::protobuf::Message for req_getBlockDetailsByRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blkNumberStart = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.blkNumberEnd = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.blkNumberStart != 0 {
            my_size += ::protobuf::rt::value_size(1, self.blkNumberStart, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.blkNumberEnd != 0 {
            my_size += ::protobuf::rt::value_size(2, self.blkNumberEnd, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.blkNumberStart != 0 {
            os.write_uint64(1, self.blkNumberStart)?;
        }
        if self.blkNumberEnd != 0 {
            os.write_uint64(2, self.blkNumberEnd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockDetailsByRange {
        req_getBlockDetailsByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blkNumberStart",
                    |m: &req_getBlockDetailsByRange| { &m.blkNumberStart },
                    |m: &mut req_getBlockDetailsByRange| { &mut m.blkNumberStart },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "blkNumberEnd",
                    |m: &req_getBlockDetailsByRange| { &m.blkNumberEnd },
                    |m: &mut req_getBlockDetailsByRange| { &mut m.blkNumberEnd },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockDetailsByRange>(
                    "req_getBlockDetailsByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockDetailsByRange {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockDetailsByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockDetailsByRange,
        };
        unsafe {
            instance.get(req_getBlockDetailsByRange::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockDetailsByRange {
    fn clear(&mut self) {
        self.clear_blkNumberStart();
        self.clear_blkNumberEnd();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockDetailsByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockDetailsByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockDetailsByRange {
    // message fields
    pub blkDetails: ::protobuf::RepeatedField<t_BlockDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockDetailsByRange {
    pub fn new() -> rsp_getBlockDetailsByRange {
        ::std::default::Default::default()
    }

    // repeated .bp_api.t_BlockDetail blkDetails = 1;

    pub fn clear_blkDetails(&mut self) {
        self.blkDetails.clear();
    }

    // Param is passed by value, moved
    pub fn set_blkDetails(&mut self, v: ::protobuf::RepeatedField<t_BlockDetail>) {
        self.blkDetails = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blkDetails(&mut self) -> &mut ::protobuf::RepeatedField<t_BlockDetail> {
        &mut self.blkDetails
    }

    // Take field
    pub fn take_blkDetails(&mut self) -> ::protobuf::RepeatedField<t_BlockDetail> {
        ::std::mem::replace(&mut self.blkDetails, ::protobuf::RepeatedField::new())
    }

    pub fn get_blkDetails(&self) -> &[t_BlockDetail] {
        &self.blkDetails
    }
}

impl ::protobuf::Message for rsp_getBlockDetailsByRange {
    fn is_initialized(&self) -> bool {
        for v in &self.blkDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.blkDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.blkDetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.blkDetails {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockDetailsByRange {
        rsp_getBlockDetailsByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_BlockDetail>>(
                    "blkDetails",
                    |m: &rsp_getBlockDetailsByRange| { &m.blkDetails },
                    |m: &mut rsp_getBlockDetailsByRange| { &mut m.blkDetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockDetailsByRange>(
                    "rsp_getBlockDetailsByRange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockDetailsByRange {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockDetailsByRange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockDetailsByRange,
        };
        unsafe {
            instance.get(rsp_getBlockDetailsByRange::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockDetailsByRange {
    fn clear(&mut self) {
        self.clear_blkDetails();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockDetailsByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockDetailsByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getNonce {
    // message fields
    pub address: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getNonce {
    pub fn new() -> req_getNonce {
        ::std::default::Default::default()
    }

    // bytes address = 1;

    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.address, ::std::vec::Vec::new())
    }

    pub fn get_address(&self) -> &[u8] {
        &self.address
    }
}

impl ::protobuf::Message for req_getNonce {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getNonce {
        req_getNonce::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "address",
                    |m: &req_getNonce| { &m.address },
                    |m: &mut req_getNonce| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getNonce>(
                    "req_getNonce",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getNonce {
        static mut instance: ::protobuf::lazy::Lazy<req_getNonce> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getNonce,
        };
        unsafe {
            instance.get(req_getNonce::new)
        }
    }
}

impl ::protobuf::Clear for req_getNonce {
    fn clear(&mut self) {
        self.clear_address();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getNonce {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getNonce {
    // message fields
    pub nonce: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getNonce {
    pub fn new() -> rsp_getNonce {
        ::std::default::Default::default()
    }

    // bytes nonce = 1;

    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::vec::Vec<u8>) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.nonce, ::std::vec::Vec::new())
    }

    pub fn get_nonce(&self) -> &[u8] {
        &self.nonce
    }
}

impl ::protobuf::Message for rsp_getNonce {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.nonce)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.nonce);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.nonce.is_empty() {
            os.write_bytes(1, &self.nonce)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getNonce {
        rsp_getNonce::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "nonce",
                    |m: &rsp_getNonce| { &m.nonce },
                    |m: &mut rsp_getNonce| { &mut m.nonce },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getNonce>(
                    "rsp_getNonce",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getNonce {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getNonce> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getNonce,
        };
        unsafe {
            instance.get(rsp_getNonce::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getNonce {
    fn clear(&mut self) {
        self.clear_nonce();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getNonce {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getNrgPrice {
    // message fields
    pub nrgPrice: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getNrgPrice {
    pub fn new() -> rsp_getNrgPrice {
        ::std::default::Default::default()
    }

    // uint64 nrgPrice = 1;

    pub fn clear_nrgPrice(&mut self) {
        self.nrgPrice = 0;
    }

    // Param is passed by value, moved
    pub fn set_nrgPrice(&mut self, v: u64) {
        self.nrgPrice = v;
    }

    pub fn get_nrgPrice(&self) -> u64 {
        self.nrgPrice
    }
}

impl ::protobuf::Message for rsp_getNrgPrice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.nrgPrice = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.nrgPrice != 0 {
            my_size += ::protobuf::rt::value_size(1, self.nrgPrice, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.nrgPrice != 0 {
            os.write_uint64(1, self.nrgPrice)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getNrgPrice {
        rsp_getNrgPrice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "nrgPrice",
                    |m: &rsp_getNrgPrice| { &m.nrgPrice },
                    |m: &mut rsp_getNrgPrice| { &mut m.nrgPrice },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getNrgPrice>(
                    "rsp_getNrgPrice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getNrgPrice {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getNrgPrice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getNrgPrice,
        };
        unsafe {
            instance.get(rsp_getNrgPrice::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getNrgPrice {
    fn clear(&mut self) {
        self.clear_nrgPrice();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getNrgPrice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getNrgPrice {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct req_getBlockDetailsByHash {
    // message fields
    pub blockHash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl req_getBlockDetailsByHash {
    pub fn new() -> req_getBlockDetailsByHash {
        ::std::default::Default::default()
    }

    // bytes blockHash = 1;

    pub fn clear_blockHash(&mut self) {
        self.blockHash.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockHash(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockHash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockHash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockHash
    }

    // Take field
    pub fn take_blockHash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockHash, ::std::vec::Vec::new())
    }

    pub fn get_blockHash(&self) -> &[u8] {
        &self.blockHash
    }
}

impl ::protobuf::Message for req_getBlockDetailsByHash {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.blockHash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.blockHash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.blockHash.is_empty() {
            os.write_bytes(1, &self.blockHash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> req_getBlockDetailsByHash {
        req_getBlockDetailsByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockHash",
                    |m: &req_getBlockDetailsByHash| { &m.blockHash },
                    |m: &mut req_getBlockDetailsByHash| { &mut m.blockHash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<req_getBlockDetailsByHash>(
                    "req_getBlockDetailsByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static req_getBlockDetailsByHash {
        static mut instance: ::protobuf::lazy::Lazy<req_getBlockDetailsByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const req_getBlockDetailsByHash,
        };
        unsafe {
            instance.get(req_getBlockDetailsByHash::new)
        }
    }
}

impl ::protobuf::Clear for req_getBlockDetailsByHash {
    fn clear(&mut self) {
        self.clear_blockHash();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for req_getBlockDetailsByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for req_getBlockDetailsByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_getBlockDetailsByHash {
    // message fields
    pub blkDetails: ::protobuf::SingularPtrField<t_BlockDetail>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_getBlockDetailsByHash {
    pub fn new() -> rsp_getBlockDetailsByHash {
        ::std::default::Default::default()
    }

    // .bp_api.t_BlockDetail blkDetails = 1;

    pub fn clear_blkDetails(&mut self) {
        self.blkDetails.clear();
    }

    pub fn has_blkDetails(&self) -> bool {
        self.blkDetails.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blkDetails(&mut self, v: t_BlockDetail) {
        self.blkDetails = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blkDetails(&mut self) -> &mut t_BlockDetail {
        if self.blkDetails.is_none() {
            self.blkDetails.set_default();
        }
        self.blkDetails.as_mut().unwrap()
    }

    // Take field
    pub fn take_blkDetails(&mut self) -> t_BlockDetail {
        self.blkDetails.take().unwrap_or_else(|| t_BlockDetail::new())
    }

    pub fn get_blkDetails(&self) -> &t_BlockDetail {
        self.blkDetails.as_ref().unwrap_or_else(|| t_BlockDetail::default_instance())
    }
}

impl ::protobuf::Message for rsp_getBlockDetailsByHash {
    fn is_initialized(&self) -> bool {
        for v in &self.blkDetails {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.blkDetails)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blkDetails.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blkDetails.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_getBlockDetailsByHash {
        rsp_getBlockDetailsByHash::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<t_BlockDetail>>(
                    "blkDetails",
                    |m: &rsp_getBlockDetailsByHash| { &m.blkDetails },
                    |m: &mut rsp_getBlockDetailsByHash| { &mut m.blkDetails },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_getBlockDetailsByHash>(
                    "rsp_getBlockDetailsByHash",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_getBlockDetailsByHash {
        static mut instance: ::protobuf::lazy::Lazy<rsp_getBlockDetailsByHash> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_getBlockDetailsByHash,
        };
        unsafe {
            instance.get(rsp_getBlockDetailsByHash::new)
        }
    }
}

impl ::protobuf::Clear for rsp_getBlockDetailsByHash {
    fn clear(&mut self) {
        self.clear_blkDetails();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_getBlockDetailsByHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_getBlockDetailsByHash {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_listening {
    // message fields
    pub isListening: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_listening {
    pub fn new() -> rsp_listening {
        ::std::default::Default::default()
    }

    // bool isListening = 1;

    pub fn clear_isListening(&mut self) {
        self.isListening = false;
    }

    // Param is passed by value, moved
    pub fn set_isListening(&mut self, v: bool) {
        self.isListening = v;
    }

    pub fn get_isListening(&self) -> bool {
        self.isListening
    }
}

impl ::protobuf::Message for rsp_listening {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isListening = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.isListening != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.isListening != false {
            os.write_bool(1, self.isListening)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_listening {
        rsp_listening::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isListening",
                    |m: &rsp_listening| { &m.isListening },
                    |m: &mut rsp_listening| { &mut m.isListening },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_listening>(
                    "rsp_listening",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_listening {
        static mut instance: ::protobuf::lazy::Lazy<rsp_listening> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_listening,
        };
        unsafe {
            instance.get(rsp_listening::new)
        }
    }
}

impl ::protobuf::Clear for rsp_listening {
    fn clear(&mut self) {
        self.clear_isListening();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_listening {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_listening {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct rsp_peerCount {
    // message fields
    pub peers: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::protobuf::CachedSize,
}

impl rsp_peerCount {
    pub fn new() -> rsp_peerCount {
        ::std::default::Default::default()
    }

    // uint32 peers = 1;

    pub fn clear_peers(&mut self) {
        self.peers = 0;
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: u32) {
        self.peers = v;
    }

    pub fn get_peers(&self) -> u32 {
        self.peers
    }
}

impl ::protobuf::Message for rsp_peerCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.peers = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.peers != 0 {
            my_size += ::protobuf::rt::value_size(1, self.peers, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.peers != 0 {
            os.write_uint32(1, self.peers)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> rsp_peerCount {
        rsp_peerCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "peers",
                    |m: &rsp_peerCount| { &m.peers },
                    |m: &mut rsp_peerCount| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<rsp_peerCount>(
                    "rsp_peerCount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static rsp_peerCount {
        static mut instance: ::protobuf::lazy::Lazy<rsp_peerCount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const rsp_peerCount,
        };
        unsafe {
            instance.get(rsp_peerCount::new)
        }
    }
}

impl ::protobuf::Clear for rsp_peerCount {
    fn clear(&mut self) {
        self.clear_peers();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for rsp_peerCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for rsp_peerCount {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Servs {
    s_hb = 0,
    s_admin = 1,
    s_chain = 2,
    s_account = 3,
    s_tx = 4,
    s_net = 5,
    s_mine = 6,
    s_privilege = 7,
    s_wallet = 8,
    s_NA = 9,
}

impl ::protobuf::ProtobufEnum for Servs {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Servs> {
        match value {
            0 => ::std::option::Option::Some(Servs::s_hb),
            1 => ::std::option::Option::Some(Servs::s_admin),
            2 => ::std::option::Option::Some(Servs::s_chain),
            3 => ::std::option::Option::Some(Servs::s_account),
            4 => ::std::option::Option::Some(Servs::s_tx),
            5 => ::std::option::Option::Some(Servs::s_net),
            6 => ::std::option::Option::Some(Servs::s_mine),
            7 => ::std::option::Option::Some(Servs::s_privilege),
            8 => ::std::option::Option::Some(Servs::s_wallet),
            9 => ::std::option::Option::Some(Servs::s_NA),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Servs] = &[
            Servs::s_hb,
            Servs::s_admin,
            Servs::s_chain,
            Servs::s_account,
            Servs::s_tx,
            Servs::s_net,
            Servs::s_mine,
            Servs::s_privilege,
            Servs::s_wallet,
            Servs::s_NA,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Servs", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Servs {
}

impl ::std::default::Default for Servs {
    fn default() -> Self {
        Servs::s_hb
    }
}

impl ::protobuf::reflect::ProtobufValue for Servs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Funcs {
    f_protocolVersion = 0,
    f_minerAddress = 1,
    f_accounts = 2,
    f_blockNumber = 3,
    f_getBalance = 4,
    f_getStorageAt = 5,
    f_unlockAccount = 6,
    f_sendTransaction = 7,
    f_getTransactionByHash = 8,
    f_compile = 9,
    f_contractDeploy = 10,
    f_getTransactionCount = 11,
    f_getBlockTransactionCountByHash = 12,
    f_getBlockTransactionCountByNumber = 13,
    f_getCode = 14,
    f_call = 15,
    f_getBlockByHash = 16,
    f_getBlockByNumber = 17,
    f_getTransactionByBlockHashAndIndex = 18,
    f_getTransactionByBlockNumberAndIndex = 19,
    f_getTransactionReceipt = 20,
    f_getCompilers = 21,
    f_compileSolidity = 22,
    f_getWork = 23,
    f_submitWork = 24,
    f_fetchQueuedTransactions = 25,
    f_signedTransaction = 26,
    f_rawTransaction = 27,
    f_estimateNrg = 28,
    f_mining = 29,
    f_hashrate = 30,
    f_getActiveNodes = 31,
    f_getSolcVersion = 32,
    f_isSyncing = 33,
    f_syncInfo = 34,
    f_getSystemInfo = 35,
    f_eventRegister = 36,
    f_eventDeregister = 37,
    f_accountCreate = 38,
    f_accountLock = 39,
    f_userPrivilege = 40,
    f_eventQuery = 41,
    f_importAccounts = 42,
    f_exportAccounts = 43,
    f_getBlockHeaderByNumber = 44,
    f_getBlockHeaderByHash = 45,
    f_getCurrentTotalDifficulty = 46,
    f_getStaticNodes = 47,
    f_getBlockDetailsByNumber = 48,
    f_getBlockDetailsByLatest = 49,
    f_getBlocksByLatest = 50,
    f_getAccountDetailsByAddressList = 51,
    f_backupAccounts = 52,
    f_NA = 53,
    f_getBlockSqlByRange = 54,
    f_getBlockDetailsByRange = 55,
    f_getNonce = 56,
    f_getNrgPrice = 57,
    f_getBlockDetailsByHash = 58,
    f_listening = 59,
    f_peerCount = 60,
}

impl ::protobuf::ProtobufEnum for Funcs {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Funcs> {
        match value {
            0 => ::std::option::Option::Some(Funcs::f_protocolVersion),
            1 => ::std::option::Option::Some(Funcs::f_minerAddress),
            2 => ::std::option::Option::Some(Funcs::f_accounts),
            3 => ::std::option::Option::Some(Funcs::f_blockNumber),
            4 => ::std::option::Option::Some(Funcs::f_getBalance),
            5 => ::std::option::Option::Some(Funcs::f_getStorageAt),
            6 => ::std::option::Option::Some(Funcs::f_unlockAccount),
            7 => ::std::option::Option::Some(Funcs::f_sendTransaction),
            8 => ::std::option::Option::Some(Funcs::f_getTransactionByHash),
            9 => ::std::option::Option::Some(Funcs::f_compile),
            10 => ::std::option::Option::Some(Funcs::f_contractDeploy),
            11 => ::std::option::Option::Some(Funcs::f_getTransactionCount),
            12 => ::std::option::Option::Some(Funcs::f_getBlockTransactionCountByHash),
            13 => ::std::option::Option::Some(Funcs::f_getBlockTransactionCountByNumber),
            14 => ::std::option::Option::Some(Funcs::f_getCode),
            15 => ::std::option::Option::Some(Funcs::f_call),
            16 => ::std::option::Option::Some(Funcs::f_getBlockByHash),
            17 => ::std::option::Option::Some(Funcs::f_getBlockByNumber),
            18 => ::std::option::Option::Some(Funcs::f_getTransactionByBlockHashAndIndex),
            19 => ::std::option::Option::Some(Funcs::f_getTransactionByBlockNumberAndIndex),
            20 => ::std::option::Option::Some(Funcs::f_getTransactionReceipt),
            21 => ::std::option::Option::Some(Funcs::f_getCompilers),
            22 => ::std::option::Option::Some(Funcs::f_compileSolidity),
            23 => ::std::option::Option::Some(Funcs::f_getWork),
            24 => ::std::option::Option::Some(Funcs::f_submitWork),
            25 => ::std::option::Option::Some(Funcs::f_fetchQueuedTransactions),
            26 => ::std::option::Option::Some(Funcs::f_signedTransaction),
            27 => ::std::option::Option::Some(Funcs::f_rawTransaction),
            28 => ::std::option::Option::Some(Funcs::f_estimateNrg),
            29 => ::std::option::Option::Some(Funcs::f_mining),
            30 => ::std::option::Option::Some(Funcs::f_hashrate),
            31 => ::std::option::Option::Some(Funcs::f_getActiveNodes),
            32 => ::std::option::Option::Some(Funcs::f_getSolcVersion),
            33 => ::std::option::Option::Some(Funcs::f_isSyncing),
            34 => ::std::option::Option::Some(Funcs::f_syncInfo),
            35 => ::std::option::Option::Some(Funcs::f_getSystemInfo),
            36 => ::std::option::Option::Some(Funcs::f_eventRegister),
            37 => ::std::option::Option::Some(Funcs::f_eventDeregister),
            38 => ::std::option::Option::Some(Funcs::f_accountCreate),
            39 => ::std::option::Option::Some(Funcs::f_accountLock),
            40 => ::std::option::Option::Some(Funcs::f_userPrivilege),
            41 => ::std::option::Option::Some(Funcs::f_eventQuery),
            42 => ::std::option::Option::Some(Funcs::f_importAccounts),
            43 => ::std::option::Option::Some(Funcs::f_exportAccounts),
            44 => ::std::option::Option::Some(Funcs::f_getBlockHeaderByNumber),
            45 => ::std::option::Option::Some(Funcs::f_getBlockHeaderByHash),
            46 => ::std::option::Option::Some(Funcs::f_getCurrentTotalDifficulty),
            47 => ::std::option::Option::Some(Funcs::f_getStaticNodes),
            48 => ::std::option::Option::Some(Funcs::f_getBlockDetailsByNumber),
            49 => ::std::option::Option::Some(Funcs::f_getBlockDetailsByLatest),
            50 => ::std::option::Option::Some(Funcs::f_getBlocksByLatest),
            51 => ::std::option::Option::Some(Funcs::f_getAccountDetailsByAddressList),
            52 => ::std::option::Option::Some(Funcs::f_backupAccounts),
            53 => ::std::option::Option::Some(Funcs::f_NA),
            54 => ::std::option::Option::Some(Funcs::f_getBlockSqlByRange),
            55 => ::std::option::Option::Some(Funcs::f_getBlockDetailsByRange),
            56 => ::std::option::Option::Some(Funcs::f_getNonce),
            57 => ::std::option::Option::Some(Funcs::f_getNrgPrice),
            58 => ::std::option::Option::Some(Funcs::f_getBlockDetailsByHash),
            59 => ::std::option::Option::Some(Funcs::f_listening),
            60 => ::std::option::Option::Some(Funcs::f_peerCount),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Funcs] = &[
            Funcs::f_protocolVersion,
            Funcs::f_minerAddress,
            Funcs::f_accounts,
            Funcs::f_blockNumber,
            Funcs::f_getBalance,
            Funcs::f_getStorageAt,
            Funcs::f_unlockAccount,
            Funcs::f_sendTransaction,
            Funcs::f_getTransactionByHash,
            Funcs::f_compile,
            Funcs::f_contractDeploy,
            Funcs::f_getTransactionCount,
            Funcs::f_getBlockTransactionCountByHash,
            Funcs::f_getBlockTransactionCountByNumber,
            Funcs::f_getCode,
            Funcs::f_call,
            Funcs::f_getBlockByHash,
            Funcs::f_getBlockByNumber,
            Funcs::f_getTransactionByBlockHashAndIndex,
            Funcs::f_getTransactionByBlockNumberAndIndex,
            Funcs::f_getTransactionReceipt,
            Funcs::f_getCompilers,
            Funcs::f_compileSolidity,
            Funcs::f_getWork,
            Funcs::f_submitWork,
            Funcs::f_fetchQueuedTransactions,
            Funcs::f_signedTransaction,
            Funcs::f_rawTransaction,
            Funcs::f_estimateNrg,
            Funcs::f_mining,
            Funcs::f_hashrate,
            Funcs::f_getActiveNodes,
            Funcs::f_getSolcVersion,
            Funcs::f_isSyncing,
            Funcs::f_syncInfo,
            Funcs::f_getSystemInfo,
            Funcs::f_eventRegister,
            Funcs::f_eventDeregister,
            Funcs::f_accountCreate,
            Funcs::f_accountLock,
            Funcs::f_userPrivilege,
            Funcs::f_eventQuery,
            Funcs::f_importAccounts,
            Funcs::f_exportAccounts,
            Funcs::f_getBlockHeaderByNumber,
            Funcs::f_getBlockHeaderByHash,
            Funcs::f_getCurrentTotalDifficulty,
            Funcs::f_getStaticNodes,
            Funcs::f_getBlockDetailsByNumber,
            Funcs::f_getBlockDetailsByLatest,
            Funcs::f_getBlocksByLatest,
            Funcs::f_getAccountDetailsByAddressList,
            Funcs::f_backupAccounts,
            Funcs::f_NA,
            Funcs::f_getBlockSqlByRange,
            Funcs::f_getBlockDetailsByRange,
            Funcs::f_getNonce,
            Funcs::f_getNrgPrice,
            Funcs::f_getBlockDetailsByHash,
            Funcs::f_listening,
            Funcs::f_peerCount,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Funcs", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Funcs {
}

impl ::std::default::Default for Funcs {
    fn default() -> Self {
        Funcs::f_protocolVersion
    }
}

impl ::protobuf::reflect::ProtobufValue for Funcs {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Retcode {
    r_fail = 0,
    r_success = 1,
    r_wallet_nullcb = 2,
    r_heartbeatReturn = 3,
    r_privilegeReturn = 4,
    r_tx_Init = 100,
    r_tx_Recved = 101,
    r_tx_Dropped = 102,
    r_tx_NewPending = 103,
    r_tx_Pending = 104,
    r_tx_Included = 105,
    r_tx_eventCb = 106,
    r_NA = 107,
    r_fail_header_len = -1,
    r_fail_service_call = -2,
    r_fail_function_call = -3,
    r_fail_function_exception = -4,
    r_fail_api_version = -5,
    r_fail_ct_bytecode = -6,
    r_fail_null_rsp = -7,
    r_fail_invalid_addr = -8,
    r_fail_null_compile_source = -9,
    r_fail_compile_contract = -10,
    r_fail_sendTx_null_rep = -11,
    r_fail_getcode_to = -12,
    r_fail_getTxReceipt_null_recp = -13,
    r_fail_zmqHandler_exception = -14,
    r_fail_hit_pending_tx_limit = -15,
    r_fail_txqueue_exception = -16,
    r_fail_function_arguments = -17,
    r_fail_unsupport_api = -18,
    r_fail_unknown = -19,
}

impl ::protobuf::ProtobufEnum for Retcode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Retcode> {
        match value {
            0 => ::std::option::Option::Some(Retcode::r_fail),
            1 => ::std::option::Option::Some(Retcode::r_success),
            2 => ::std::option::Option::Some(Retcode::r_wallet_nullcb),
            3 => ::std::option::Option::Some(Retcode::r_heartbeatReturn),
            4 => ::std::option::Option::Some(Retcode::r_privilegeReturn),
            100 => ::std::option::Option::Some(Retcode::r_tx_Init),
            101 => ::std::option::Option::Some(Retcode::r_tx_Recved),
            102 => ::std::option::Option::Some(Retcode::r_tx_Dropped),
            103 => ::std::option::Option::Some(Retcode::r_tx_NewPending),
            104 => ::std::option::Option::Some(Retcode::r_tx_Pending),
            105 => ::std::option::Option::Some(Retcode::r_tx_Included),
            106 => ::std::option::Option::Some(Retcode::r_tx_eventCb),
            107 => ::std::option::Option::Some(Retcode::r_NA),
            -1 => ::std::option::Option::Some(Retcode::r_fail_header_len),
            -2 => ::std::option::Option::Some(Retcode::r_fail_service_call),
            -3 => ::std::option::Option::Some(Retcode::r_fail_function_call),
            -4 => ::std::option::Option::Some(Retcode::r_fail_function_exception),
            -5 => ::std::option::Option::Some(Retcode::r_fail_api_version),
            -6 => ::std::option::Option::Some(Retcode::r_fail_ct_bytecode),
            -7 => ::std::option::Option::Some(Retcode::r_fail_null_rsp),
            -8 => ::std::option::Option::Some(Retcode::r_fail_invalid_addr),
            -9 => ::std::option::Option::Some(Retcode::r_fail_null_compile_source),
            -10 => ::std::option::Option::Some(Retcode::r_fail_compile_contract),
            -11 => ::std::option::Option::Some(Retcode::r_fail_sendTx_null_rep),
            -12 => ::std::option::Option::Some(Retcode::r_fail_getcode_to),
            -13 => ::std::option::Option::Some(Retcode::r_fail_getTxReceipt_null_recp),
            -14 => ::std::option::Option::Some(Retcode::r_fail_zmqHandler_exception),
            -15 => ::std::option::Option::Some(Retcode::r_fail_hit_pending_tx_limit),
            -16 => ::std::option::Option::Some(Retcode::r_fail_txqueue_exception),
            -17 => ::std::option::Option::Some(Retcode::r_fail_function_arguments),
            -18 => ::std::option::Option::Some(Retcode::r_fail_unsupport_api),
            -19 => ::std::option::Option::Some(Retcode::r_fail_unknown),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Retcode] = &[
            Retcode::r_fail,
            Retcode::r_success,
            Retcode::r_wallet_nullcb,
            Retcode::r_heartbeatReturn,
            Retcode::r_privilegeReturn,
            Retcode::r_tx_Init,
            Retcode::r_tx_Recved,
            Retcode::r_tx_Dropped,
            Retcode::r_tx_NewPending,
            Retcode::r_tx_Pending,
            Retcode::r_tx_Included,
            Retcode::r_tx_eventCb,
            Retcode::r_NA,
            Retcode::r_fail_header_len,
            Retcode::r_fail_service_call,
            Retcode::r_fail_function_call,
            Retcode::r_fail_function_exception,
            Retcode::r_fail_api_version,
            Retcode::r_fail_ct_bytecode,
            Retcode::r_fail_null_rsp,
            Retcode::r_fail_invalid_addr,
            Retcode::r_fail_null_compile_source,
            Retcode::r_fail_compile_contract,
            Retcode::r_fail_sendTx_null_rep,
            Retcode::r_fail_getcode_to,
            Retcode::r_fail_getTxReceipt_null_recp,
            Retcode::r_fail_zmqHandler_exception,
            Retcode::r_fail_hit_pending_tx_limit,
            Retcode::r_fail_txqueue_exception,
            Retcode::r_fail_function_arguments,
            Retcode::r_fail_unsupport_api,
            Retcode::r_fail_unknown,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Retcode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Retcode {
}

impl ::std::default::Default for Retcode {
    fn default() -> Self {
        Retcode::r_fail
    }
}

impl ::protobuf::reflect::ProtobufValue for Retcode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\x12\x06bp_api\"\xec\x01\n\nt_Contract\x12\x12\n\x04cod\
    e\x18\x01\x20\x01(\tR\x04code\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05\
    error\x12\x16\n\x06source\x18\x03\x20\x01(\tR\x06source\x12(\n\x0fcompil\
    erVersion\x18\x04\x20\x01(\tR\x0fcompilerVersion\x12(\n\x0fcompilerOptio\
    ns\x18\x05\x20\x01(\tR\x0fcompilerOptions\x12\x16\n\x06abiDef\x18\x06\
    \x20\x01(\x0cR\x06abiDef\x12\x18\n\x07userDoc\x18\x07\x20\x01(\x0cR\x07u\
    serDoc\x12\x16\n\x06devDoc\x18\x08\x20\x01(\x0cR\x06devDoc\"\xc4\x01\n\
    \x08t_AionTx\x12\x16\n\x06txHash\x18\x01\x20\x01(\x0cR\x06txHash\x12\x12\
    \n\x04from\x18\x02\x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x03\x20\x01\
    (\x0cR\x02to\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x12\x12\n\
    \x04data\x18\x05\x20\x01(\x0cR\x04data\x12\x14\n\x05nonce\x18\x06\x20\
    \x01(\x0cR\x05nonce\x12\x20\n\x0bnrgConsumed\x18\x07\x20\x01(\x04R\x0bnr\
    gConsumed\x12\x1a\n\x08nrgPrice\x18\x08\x20\x01(\x04R\x08nrgPrice\"\xa8\
    \x01\n\x06t_Node\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bblock\
    Number\x12\x16\n\x06nodeId\x18\x02\x20\x01(\tR\x06nodeId\x12\"\n\rremote\
    _p2p_ip\x18\x03\x20\x01(\tR\x0bremoteP2pIp\x12&\n\x0fremote_p2p_port\x18\
    \x04\x20\x01(\rR\rremoteP2pPort\x12\x18\n\x07latency\x18\x05\x20\x01(\rR\
    \x07latency\"O\n\x07t_LgEle\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\
    \x07address\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x16\n\
    \x06topics\x18\x03\x20\x03(\tR\x06topics\"\xaa\x01\n\nt_FilterCt\x12\x12\
    \n\x04from\x18\x01\x20\x01(\tR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\
    \tR\x02to\x12\"\n\x0ccontractAddr\x18\x03\x20\x01(\x0cR\x0ccontractAddr\
    \x12\x1c\n\taddresses\x18\x04\x20\x03(\x0cR\taddresses\x12\x16\n\x06topi\
    cs\x18\x05\x20\x03(\tR\x06topics\x12\x1e\n\nexpireTime\x18\x06\x20\x01(\
    \x04R\nexpireTime\"\xff\x01\n\tt_EventCt\x12\x18\n\x07address\x18\x01\
    \x20\x01(\x0cR\x07address\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04dat\
    a\x12\x1c\n\tblockHash\x18\x03\x20\x01(\x0cR\tblockHash\x12\x20\n\x0bblo\
    ckNumber\x18\x04\x20\x01(\x04R\x0bblockNumber\x12\x1a\n\x08logIndex\x18\
    \x05\x20\x01(\rR\x08logIndex\x12\x1c\n\teventName\x18\x06\x20\x01(\tR\te\
    ventName\x12\x18\n\x07removed\x18\x07\x20\x01(\x08R\x07removed\x12\x18\n\
    \x07txIndex\x18\x08\x20\x01(\rR\x07txIndex\x12\x16\n\x06txHash\x18\t\x20\
    \x01(\x0cR\x06txHash\"\xdb\x04\n\rt_BlockDetail\x12\x20\n\x0bblockNumber\
    \x18\x01\x20\x01(\x04R\x0bblockNumber\x12\x1c\n\ttimestamp\x18\x02\x20\
    \x01(\x04R\ttimestamp\x12\x20\n\x0bnrgConsumed\x18\x03\x20\x01(\x04R\x0b\
    nrgConsumed\x12\x1a\n\x08nrgLimit\x18\x04\x20\x01(\x04R\x08nrgLimit\x12\
    \x1e\n\nparentHash\x18\x05\x20\x01(\x0cR\nparentHash\x12\"\n\x0cminerAdd\
    ress\x18\x06\x20\x01(\x0cR\x0cminerAddress\x12\x1c\n\tstateRoot\x18\x07\
    \x20\x01(\x0cR\tstateRoot\x12\x1e\n\ntxTrieRoot\x18\x08\x20\x01(\x0cR\nt\
    xTrieRoot\x12(\n\x0freceiptTrieRoot\x18\t\x20\x01(\x0cR\x0freceiptTrieRo\
    ot\x12\x1c\n\tlogsBloom\x18\n\x20\x01(\x0cR\tlogsBloom\x12\x1e\n\ndiffic\
    ulty\x18\x0b\x20\x01(\x0cR\ndifficulty\x12(\n\x0ftotalDifficulty\x18\x0c\
    \x20\x01(\x0cR\x0ftotalDifficulty\x12\x1c\n\textraData\x18\r\x20\x01(\
    \x0cR\textraData\x12\x14\n\x05nonce\x18\x0e\x20\x01(\x0cR\x05nonce\x12\
    \x1a\n\x08solution\x18\x0f\x20\x01(\x0cR\x08solution\x12\x12\n\x04hash\
    \x18\x10\x20\x01(\x0cR\x04hash\x12\x12\n\x04size\x18\x11\x20\x01(\rR\x04\
    size\x12\"\n\x02tx\x18\x12\x20\x03(\x0b2\x12.bp_api.t_TxDetailR\x02tx\
    \x12\x1c\n\tblockTime\x18\x13\x20\x01(\x04R\tblockTime\"\xd5\x02\n\nt_Tx\
    Detail\x12\x16\n\x06txHash\x18\x01\x20\x01(\x0cR\x06txHash\x12\x12\n\x04\
    from\x18\x02\x20\x01(\x0cR\x04from\x12\x0e\n\x02to\x18\x03\x20\x01(\x0cR\
    \x02to\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\x05value\x12\x12\n\x04da\
    ta\x18\x05\x20\x01(\x0cR\x04data\x12\x14\n\x05nonce\x18\x06\x20\x01(\x0c\
    R\x05nonce\x12\x20\n\x0bnrgConsumed\x18\x07\x20\x01(\x04R\x0bnrgConsumed\
    \x12\x1a\n\x08nrgPrice\x18\x08\x20\x01(\x04R\x08nrgPrice\x12\x18\n\x07tx\
    Index\x18\t\x20\x01(\rR\x07txIndex\x12\x1a\n\x08contract\x18\n\x20\x01(\
    \x0cR\x08contract\x12#\n\x04logs\x18\x0b\x20\x03(\x0b2\x0f.bp_api.t_LgEl\
    eR\x04logs\x12\x1c\n\ttimestamp\x18\x0c\x20\x01(\x04R\ttimestamp\x12\x14\
    \n\x05error\x18\r\x20\x01(\tR\x05error\"E\n\x0ft_AccountDetail\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x18\n\x07balance\x18\
    \x02\x20\x01(\x0cR\x07balance\"\xab\x04\n\x07t_Block\x12\x20\n\x0bblockN\
    umber\x18\x01\x20\x01(\x04R\x0bblockNumber\x12\x1c\n\ttimestamp\x18\x02\
    \x20\x01(\x04R\ttimestamp\x12\x20\n\x0bnrgConsumed\x18\x03\x20\x01(\x04R\
    \x0bnrgConsumed\x12\x1a\n\x08nrgLimit\x18\x04\x20\x01(\x04R\x08nrgLimit\
    \x12\x1e\n\nparentHash\x18\x05\x20\x01(\x0cR\nparentHash\x12\"\n\x0cmine\
    rAddress\x18\x06\x20\x01(\x0cR\x0cminerAddress\x12\x1c\n\tstateRoot\x18\
    \x07\x20\x01(\x0cR\tstateRoot\x12\x1e\n\ntxTrieRoot\x18\x08\x20\x01(\x0c\
    R\ntxTrieRoot\x12(\n\x0freceiptTrieRoot\x18\t\x20\x01(\x0cR\x0freceiptTr\
    ieRoot\x12\x1c\n\tlogsBloom\x18\n\x20\x01(\x0cR\tlogsBloom\x12\x1e\n\ndi\
    fficulty\x18\x0b\x20\x01(\x0cR\ndifficulty\x12(\n\x0ftotalDifficulty\x18\
    \x0c\x20\x01(\x0cR\x0ftotalDifficulty\x12\x1c\n\textraData\x18\r\x20\x01\
    (\x0cR\textraData\x12\x14\n\x05nonce\x18\x0e\x20\x01(\x0cR\x05nonce\x12\
    \x1a\n\x08solution\x18\x0f\x20\x01(\x0cR\x08solution\x12\x12\n\x04hash\
    \x18\x10\x20\x01(\x0cR\x04hash\x12\x12\n\x04size\x18\x11\x20\x01(\rR\x04\
    size\x12\x16\n\x06txHash\x18\x12\x20\x03(\x0cR\x06txHash\"\x92\x01\n\nt_\
    BlockSql\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bblockNumber\
    \x12\x1c\n\tblockHash\x18\x02\x20\x01(\tR\tblockHash\x12\x1e\n\nparentHa\
    sh\x18\x03\x20\x01(\tR\nparentHash\x12\x14\n\x05block\x18\x04\x20\x01(\t\
    R\x05block\x12\x0e\n\x02tx\x18\x05\x20\x03(\tR\x02tx\"*\n\x0crsp_errorms\
    g\x12\x1a\n\x08errormsg\x18\x01\x20\x01(\tR\x08errormsg\"\x9f\x01\n\x13r\
    sp_protocolVersion\x12\x16\n\x06kernel\x18\x01\x20\x01(\tR\x06kernel\x12\
    \x10\n\x03net\x18\x02\x20\x01(\tR\x03net\x12\x10\n\x03api\x18\x03\x20\
    \x01(\tR\x03api\x12\x0e\n\x02vm\x18\x04\x20\x01(\tR\x02vm\x12\x0e\n\x02d\
    b\x18\x05\x20\x01(\tR\x02db\x12\x14\n\x05miner\x18\x06\x20\x01(\tR\x05mi\
    ner\x12\x16\n\x06txpool\x18\x07\x20\x01(\tR\x06txpool\"0\n\x10rsp_minerA\
    ddress\x12\x1c\n\tminerAddr\x18\x01\x20\x01(\x0cR\tminerAddr\"8\n\x14req\
    _getBlockByNumber\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bbloc\
    kNumber\"\xb0\x04\n\x0crsp_getBlock\x12\x20\n\x0bblockNumber\x18\x01\x20\
    \x01(\x04R\x0bblockNumber\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x04R\tti\
    mestamp\x12\x20\n\x0bnrgConsumed\x18\x03\x20\x01(\x04R\x0bnrgConsumed\
    \x12\x1a\n\x08nrgLimit\x18\x04\x20\x01(\x04R\x08nrgLimit\x12\x1e\n\npare\
    ntHash\x18\x05\x20\x01(\x0cR\nparentHash\x12\"\n\x0cminerAddress\x18\x06\
    \x20\x01(\x0cR\x0cminerAddress\x12\x1c\n\tstateRoot\x18\x07\x20\x01(\x0c\
    R\tstateRoot\x12\x1e\n\ntxTrieRoot\x18\x08\x20\x01(\x0cR\ntxTrieRoot\x12\
    (\n\x0freceiptTrieRoot\x18\t\x20\x01(\x0cR\x0freceiptTrieRoot\x12\x1c\n\
    \tlogsBloom\x18\n\x20\x01(\x0cR\tlogsBloom\x12\x1e\n\ndifficulty\x18\x0b\
    \x20\x01(\x0cR\ndifficulty\x12(\n\x0ftotalDifficulty\x18\x0c\x20\x01(\
    \x0cR\x0ftotalDifficulty\x12\x1c\n\textraData\x18\r\x20\x01(\x0cR\textra\
    Data\x12\x14\n\x05nonce\x18\x0e\x20\x01(\x0cR\x05nonce\x12\x1a\n\x08solu\
    tion\x18\x0f\x20\x01(\x0cR\x08solution\x12\x12\n\x04hash\x18\x10\x20\x01\
    (\x0cR\x04hash\x12\x12\n\x04size\x18\x11\x20\x01(\rR\x04size\x12\x16\n\
    \x06txHash\x18\x12\x20\x03(\x0cR\x06txHash\">\n\x1areq_getBlockHeaderByN\
    umber\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bblockNumber\"\
    \xf4\x03\n\x12rsp_getBlockHeader\x12\x20\n\x0bblockNumber\x18\x01\x20\
    \x01(\x04R\x0bblockNumber\x12\x1c\n\ttimestamp\x18\x02\x20\x01(\x04R\tti\
    mestamp\x12\x20\n\x0bnrgConsumed\x18\x03\x20\x01(\x04R\x0bnrgConsumed\
    \x12\x1a\n\x08nrgLimit\x18\x04\x20\x01(\x04R\x08nrgLimit\x12\x1e\n\npare\
    ntHash\x18\x05\x20\x01(\x0cR\nparentHash\x12\"\n\x0cminerAddress\x18\x06\
    \x20\x01(\x0cR\x0cminerAddress\x12\x1c\n\tstateRoot\x18\x07\x20\x01(\x0c\
    R\tstateRoot\x12\x1e\n\ntxTrieRoot\x18\x08\x20\x01(\x0cR\ntxTrieRoot\x12\
    (\n\x0freceiptTrieRoot\x18\t\x20\x01(\x0cR\x0freceiptTrieRoot\x12\x1c\n\
    \tlogsBloom\x18\n\x20\x01(\x0cR\tlogsBloom\x12\x1e\n\ndifficulty\x18\x0b\
    \x20\x01(\x0cR\ndifficulty\x12\x1c\n\textraData\x18\x0c\x20\x01(\x0cR\te\
    xtraData\x12\x14\n\x05nonce\x18\r\x20\x01(\x0cR\x05nonce\x12\x1a\n\x08so\
    lution\x18\x0e\x20\x01(\x0cR\x08solution\x12\x12\n\x04hash\x18\x0f\x20\
    \x01(\x0cR\x04hash\x12\x12\n\x04size\x18\x10\x20\x01(\rR\x04size\"\xa7\
    \x01\n\x13req_sendTransaction\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\
    \x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x0cR\x05value\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\
    \x04data\x12\x14\n\x05nonce\x18\x05\x20\x01(\x0cR\x05nonce\x12\x10\n\x03\
    nrg\x18\x06\x20\x01(\x04R\x03nrg\x12\x1a\n\x08nrgPrice\x18\x07\x20\x01(\
    \x04R\x08nrgPrice\"-\n\x13rsp_sendTransaction\x12\x16\n\x06txHash\x18\
    \x01\x20\x01(\x0cR\x06txHash\"2\n\x18req_getTransactionByHash\x12\x16\n\
    \x06txHash\x18\x01\x20\x01(\x0cR\x06txHash\"\xc4\x02\n\x12rsp_getTransac\
    tion\x12\x18\n\x07txIndex\x18\x01\x20\x01(\rR\x07txIndex\x12\x20\n\x0bbl\
    ocknumber\x18\x02\x20\x01(\x04R\x0bblocknumber\x12\x1c\n\ttimeStamp\x18\
    \x03\x20\x01(\x04R\ttimeStamp\x12\x1e\n\nnrgConsume\x18\x04\x20\x01(\x04\
    R\nnrgConsume\x12\x1a\n\x08nrgPrice\x18\x05\x20\x01(\x04R\x08nrgPrice\
    \x12\x1c\n\tblockhash\x18\x06\x20\x01(\x0cR\tblockhash\x12\x12\n\x04from\
    \x18\x07\x20\x01(\x0cR\x04from\x12\x16\n\x06txHash\x18\x08\x20\x01(\x0cR\
    \x06txHash\x12\x12\n\x04data\x18\t\x20\x01(\x0cR\x04data\x12\x14\n\x05no\
    nce\x18\n\x20\x01(\x0cR\x05nonce\x12\x0e\n\x02to\x18\x0b\x20\x01(\x0cR\
    \x02to\x12\x14\n\x05value\x18\x0c\x20\x01(\x0cR\x05value\"e\n\x11req_unl\
    ockAccount\x12\x18\n\x07account\x18\x01\x20\x01(\x0cR\x07account\x12\x1a\
    \n\x08password\x18\x02\x20\x01(\tR\x08password\x12\x1a\n\x08duration\x18\
    \x03\x20\x01(\rR\x08duration\"&\n\x0crsp_accounts\x12\x16\n\x06accout\
    \x18\x01\x20\x03(\x0cR\x06accout\"!\n\x0breq_compile\x12\x12\n\x04code\
    \x18\x01\x20\x01(\tR\x04code\"\xa5\x01\n\x0brsp_compile\x12C\n\nconstrac\
    ts\x18\x01\x20\x03(\x0b2#.bp_api.rsp_compile.ConstractsEntryR\nconstract\
    s\x1aQ\n\x0fConstractsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.bp_api.t_ContractR\x05value:\
    \x028\x01\"I\n\x0breq_getCode\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\
    \x07address\x12\x20\n\x0bblocknumber\x18\x02\x20\x01(\x04R\x0bblocknumbe\
    r\"!\n\x0brsp_getCode\x12\x12\n\x04code\x18\x01\x20\x01(\x0cR\x04code\"\
    \x8a\x01\n\x12req_contractDeploy\x12\x1a\n\x08nrgLimit\x18\x01\x20\x01(\
    \x04R\x08nrgLimit\x12\x1a\n\x08nrgPrice\x18\x02\x20\x01(\x04R\x08nrgPric\
    e\x12\x12\n\x04from\x18\x03\x20\x01(\x0cR\x04from\x12\x12\n\x04data\x18\
    \x04\x20\x01(\x0cR\x04data\x12\x14\n\x05value\x18\x05\x20\x01(\x0cR\x05v\
    alue\"V\n\x12rsp_contractDeploy\x12\x16\n\x06txHash\x18\x01\x20\x01(\x0c\
    R\x06txHash\x12(\n\x0fcontractAddress\x18\x02\x20\x01(\x0cR\x0fcontractA\
    ddress\"\x86\x01\n\x08req_call\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\
    \x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12\x12\n\x04data\
    \x18\x03\x20\x01(\x0cR\x04data\x12\x14\n\x05value\x18\x04\x20\x01(\x0cR\
    \x05value\x12\x10\n\x03nrg\x18\x05\x20\x01(\x04R\x03nrg\x12\x1a\n\x08nrg\
    Price\x18\x06\x20\x01(\x04R\x08nrgPrice\"\"\n\x08rsp_call\x12\x16\n\x06r\
    esult\x18\x01\x20\x01(\x0cR\x06result\"2\n\x12req_getBlockByHash\x12\x1c\
    \n\tblockHash\x18\x01\x20\x01(\x0cR\tblockHash\"8\n\x18req_getBlockHeade\
    rByHash\x12\x1c\n\tblockHash\x18\x01\x20\x01(\x0cR\tblockHash\"U\n\x17re\
    q_getTransactionCount\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07addr\
    ess\x12\x20\n\x0bblocknumber\x18\x02\x20\x01(\x04R\x0bblocknumber\"3\n\
    \x17rsp_getTransactionCount\x12\x18\n\x07txCount\x18\x01\x20\x01(\x04R\
    \x07txCount\"7\n\x1dreq_getTransactionCountByHash\x12\x16\n\x06txHash\
    \x18\x01\x20\x01(\x0cR\x06txHash\"3\n\x0frsp_blockNumber\x12\x20\n\x0bbl\
    ocknumber\x18\x01\x20\x01(\x04R\x0bblocknumber\"L\n\x0ereq_getBalance\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x20\n\x0bbloc\
    kNumber\x18\x02\x20\x01(\x04R\x0bblockNumber\"*\n\x0ersp_getBalance\x12\
    \x18\n\x07balance\x18\x01\x20\x01(\x0cR\x07balance\"j\n\x10req_getStorag\
    eAt\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x1a\n\x08p\
    osition\x18\x02\x20\x01(\rR\x08position\x12\x20\n\x0bblocknumber\x18\x03\
    \x20\x01(\x04R\x0bblocknumber\",\n\x10rsp_getStorageAt\x12\x18\n\x07stor\
    age\x18\x01\x20\x01(\tR\x07storage\"B\n\"req_getBlockTransactionCountByH\
    ash\x12\x1c\n\tblockHash\x18\x01\x20\x01(\x0cR\tblockHash\"8\n\x1crsp_ge\
    tBlockTransactionCount\x12\x18\n\x07txCount\x18\x01\x20\x01(\rR\x07txCou\
    nt\"H\n$req_getBlockTransactionCountByNumber\x12\x20\n\x0bblockNumber\
    \x18\x01\x20\x01(\x04R\x0bblockNumber\"_\n%req_getTransactionByBlockHash\
    AndIndex\x12\x1c\n\tblockHash\x18\x01\x20\x01(\x0cR\tblockHash\x12\x18\n\
    \x07txIndex\x18\x02\x20\x01(\rR\x07txIndex\"e\n'req_getTransactionByBloc\
    kNumberAndIndex\x12\x20\n\x0bblockNumber\x18\x01\x20\x01(\x04R\x0bblockN\
    umber\x12\x18\n\x07txIndex\x18\x02\x20\x01(\rR\x07txIndex\"3\n\x19req_ge\
    tTransactionReceipt\x12\x16\n\x06txHash\x18\x01\x20\x01(\x0cR\x06txHash\
    \"\xd0\x02\n\x19rsp_getTransactionReceipt\x12\x18\n\x07txIndex\x18\x01\
    \x20\x01(\rR\x07txIndex\x12\x20\n\x0bblockNumber\x18\x02\x20\x01(\x04R\
    \x0bblockNumber\x12\x20\n\x0bnrgConsumed\x18\x03\x20\x01(\x04R\x0bnrgCon\
    sumed\x12,\n\x11cumulativeNrgUsed\x18\x04\x20\x01(\x04R\x11cumulativeNrg\
    Used\x12\x1c\n\tblockHash\x18\x05\x20\x01(\x0cR\tblockHash\x12\x16\n\x06\
    txHash\x18\x06\x20\x01(\x0cR\x06txHash\x12\x12\n\x04from\x18\x07\x20\x01\
    (\x0cR\x04from\x12\x0e\n\x02to\x18\x08\x20\x01(\x0cR\x02to\x12(\n\x0fcon\
    tractAddress\x18\t\x20\x01(\x0cR\x0fcontractAddress\x12#\n\x04logs\x18\n\
    \x20\x03(\x0b2\x0f.bp_api.t_LgEleR\x04logs\"U\n\x1freq_getUncleByBlockHa\
    shAndIndex\x12\x1c\n\tblockHash\x18\x01\x20\x01(\x0cR\tblockHash\x12\x14\
    \n\x05index\x18\x02\x20\x01(\rR\x05index\".\n\x10rsp_getCompilers\x12\
    \x1a\n\x08compiler\x18\x01\x20\x03(\tR\x08compiler\"-\n\x13req_compileSo\
    lidity\x12\x16\n\x06source\x18\x01\x20\x01(\tR\x06source\"Q\n\x13rsp_com\
    pileSolidity\x12\x12\n\x04code\x18\x01\x20\x01(\tR\x04code\x12&\n\x04inf\
    o\x18\x02\x20\x01(\x0b2\x12.bp_api.t_ContractR\x04info\"!\n\x0brsp_getWo\
    rk\x12\x12\n\x04work\x18\x01\x20\x03(\tR\x04work\"Z\n\x0ereq_submitWork\
    \x12\x14\n\x05nonce\x18\x01\x20\x01(\x0cR\x05nonce\x12\x1a\n\x08solution\
    \x18\x02\x20\x01(\x0cR\x08solution\x12\x16\n\x06digest\x18\x03\x20\x01(\
    \x0cR\x06digest\"4\n\x0ersp_submitWork\x12\"\n\x0cworkAccepted\x18\x01\
    \x20\x01(\x08R\x0cworkAccepted\"?\n\x1brsp_fetchQueuedTransactions\x12\
    \x20\n\x02tx\x18\x01\x20\x03(\x0b2\x10.bp_api.t_AionTxR\x02tx\"2\n\x12re\
    q_rawTransaction\x12\x1c\n\tencodedTx\x18\x01\x20\x01(\x0cR\tencodedTx\"\
    \x8d\x01\n\x0freq_estimateNrg\x12\x12\n\x04from\x18\x01\x20\x01(\x0cR\
    \x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\x0cR\x02to\x12\x14\n\x05value\
    \x18\x03\x20\x01(\x0cR\x05value\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\
    \x04data\x12\x10\n\x03nrg\x18\x05\x20\x01(\x04R\x03nrg\x12\x1a\n\x08nrgP\
    rice\x18\x06\x20\x01(\x04R\x08nrgPrice\"#\n\x0frsp_estimateNrg\x12\x10\n\
    \x03nrg\x18\x01\x20\x01(\x04R\x03nrg\"$\n\nrsp_mining\x12\x16\n\x06minin\
    g\x18\x01\x20\x01(\x08R\x06mining\"*\n\x0crsp_hashrate\x12\x1a\n\x08hash\
    rate\x18\x01\x20\x01(\x04R\x08hashrate\"8\n\x12rsp_getActiveNodes\x12\"\
    \n\x04node\x18\x01\x20\x03(\x0b2\x0e.bp_api.t_NodeR\x04node\"8\n\x12rsp_\
    getStaticNodes\x12\"\n\x04node\x18\x01\x20\x03(\x0b2\x0e.bp_api.t_NodeR\
    \x04node\"&\n\x12rsp_getSolcVersion\x12\x10\n\x03ver\x18\x01\x20\x01(\tR\
    \x03ver\")\n\rrsp_isSyncing\x12\x18\n\x07syncing\x18\x01\x20\x01(\x08R\
    \x07syncing\"\xcc\x01\n\x0crsp_syncInfo\x12\x18\n\x07syncing\x18\x01\x20\
    \x01(\x08R\x07syncing\x12*\n\x10networkBestBlock\x18\x02\x20\x01(\x04R\
    \x10networkBestBlock\x12&\n\x0echainBestBlock\x18\x03\x20\x01(\x04R\x0ec\
    hainBestBlock\x12(\n\x0fmaxImportBlocks\x18\x04\x20\x01(\rR\x0fmaxImport\
    Blocks\x12$\n\rstartingBlock\x18\x05\x20\x01(\x04R\rstartingBlock\"f\n\
    \x0ersp_systemInfo\x12\x1a\n\x08cpuUsage\x18\x01\x20\x01(\x02R\x08cpuUsa\
    ge\x12\x20\n\x0bmemoryUsage\x18\x02\x20\x01(\x04R\x0bmemoryUsage\x12\x16\
    \n\x06DBSize\x18\x03\x20\x01(\x04R\x06DBSize\"W\n\x11req_eventRegister\
    \x12\x16\n\x06events\x18\x01\x20\x03(\tR\x06events\x12*\n\x06filter\x18\
    \x02\x20\x01(\x0b2\x12.bp_api.t_FilterCtR\x06filter\"+\n\x11rsp_eventReg\
    ister\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\"Q\n\x13req_ev\
    entDeregister\x12\x16\n\x06events\x18\x01\x20\x03(\tR\x06events\x12\"\n\
    \x0ccontractAddr\x18\x02\x20\x01(\x0cR\x0ccontractAddr\"-\n\x13rsp_event\
    Deregister\x12\x16\n\x06result\x18\x01\x20\x01(\x08R\x06result\"8\n\x13r\
    sp_EventCtCallback\x12!\n\x02ec\x18\x01\x20\x03(\x0b2\x11.bp_api.t_Event\
    CtR\x02ec\"O\n\x11req_accountCreate\x12\x1a\n\x08password\x18\x01\x20\
    \x03(\tR\x08password\x12\x1e\n\nprivateKey\x18\x02\x20\x01(\x08R\nprivat\
    eKey\"M\n\x11rsp_accountCreate\x12\x18\n\x07address\x18\x01\x20\x03(\x0c\
    R\x07address\x12\x1e\n\nprivateKey\x18\x02\x20\x03(\x0cR\nprivateKey\"G\
    \n\x0freq_accountlock\x12\x18\n\x07account\x18\x01\x20\x01(\x0cR\x07acco\
    unt\x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\")\n\x0frsp_ac\
    countlock\x12\x16\n\x06locked\x18\x01\x20\x01(\x08R\x06locked\"K\n\x11re\
    q_userPrivilege\x12\x1a\n\x08username\x18\x01\x20\x01(\tR\x08username\
    \x12\x1a\n\x08password\x18\x02\x20\x01(\tR\x08password\"1\n\x11rsp_userP\
    rivilege\x12\x1c\n\tprivilege\x18\x01\x20\x03(\tR\tprivilege\"?\n\x11req\
    _queryCtEvents\x12*\n\x06filter\x18\x01\x20\x01(\x0b2\x12.bp_api.t_Filte\
    rCtR\x06filter\"6\n\x11rsp_queryCtEvents\x12!\n\x02ec\x18\x01\x20\x03(\
    \x0b2\x11.bp_api.t_EventCtR\x02ec\"J\n\x0ct_PrivateKey\x12\x1e\n\nprivat\
    eKey\x18\x01\x20\x01(\tR\nprivateKey\x12\x1a\n\x08password\x18\x02\x20\
    \x01(\tR\x08password\"J\n\x12req_importAccounts\x124\n\nprivateKey\x18\
    \x01\x20\x03(\x0b2\x14.bp_api.t_PrivateKeyR\nprivateKey\"4\n\x12rsp_impo\
    rtAccounts\x12\x1e\n\ninvalidKey\x18\x01\x20\x03(\tR\ninvalidKey\"=\n\
    \x05t_Key\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\x12\x1a\
    \n\x08password\x18\x02\x20\x01(\tR\x08password\"=\n\x12req_exportAccount\
    s\x12'\n\x07keyFile\x18\x01\x20\x03(\x0b2\r.bp_api.t_KeyR\x07keyFile\"L\
    \n\x12rsp_exportAccounts\x12\x18\n\x07keyFile\x18\x01\x20\x03(\x0cR\x07k\
    eyFile\x12\x1c\n\tfailedKey\x18\x02\x20\x03(\x0cR\tfailedKey\"=\n\x1drsp\
    _getCurrentTotalDifficulty\x12\x1c\n\ttotalDiff\x18\x01\x20\x01(\x0cR\tt\
    otalDiff\"=\n\x1breq_getBlockDetailsByNumber\x12\x1e\n\nblkNumbers\x18\
    \x01\x20\x03(\x04R\nblkNumbers\"T\n\x1brsp_getBlockDetailsByNumber\x125\
    \n\nblkDetails\x18\x01\x20\x03(\x0b2\x15.bp_api.t_BlockDetailR\nblkDetai\
    ls\"3\n\x1breq_getBlockDetailsByLatest\x12\x14\n\x05count\x18\x01\x20\
    \x01(\x04R\x05count\"T\n\x1brsp_getBlockDetailsByLatest\x125\n\nblkDetai\
    ls\x18\x01\x20\x03(\x0b2\x15.bp_api.t_BlockDetailR\nblkDetails\"-\n\x15r\
    eq_getBlocksByLatest\x12\x14\n\x05count\x18\x01\x20\x01(\x04R\x05count\"\
    <\n\x15rsp_getBlocksByLatest\x12#\n\x04blks\x18\x01\x20\x03(\x0b2\x0f.bp\
    _api.t_BlockR\x04blks\"B\n\"req_getAccountDetailsByAddressList\x12\x1c\n\
    \taddresses\x18\x01\x20\x03(\x0cR\taddresses\"Y\n\"rsp_getAccountDetails\
    ByAddressList\x123\n\x08accounts\x18\x01\x20\x03(\x0b2\x17.bp_api.t_Acco\
    untDetailR\x08accounts\"d\n\x16req_getBlockSqlByRange\x12&\n\x0eblkNumbe\
    rStart\x18\x01\x20\x01(\x04R\x0eblkNumberStart\x12\"\n\x0cblkNumberEnd\
    \x18\x02\x20\x01(\x04R\x0cblkNumberEnd\"D\n\x16rsp_getBlockSqlByRange\
    \x12*\n\x06blkSql\x18\x01\x20\x03(\x0b2\x12.bp_api.t_BlockSqlR\x06blkSql\
    \"h\n\x1areq_getBlockDetailsByRange\x12&\n\x0eblkNumberStart\x18\x01\x20\
    \x01(\x04R\x0eblkNumberStart\x12\"\n\x0cblkNumberEnd\x18\x02\x20\x01(\
    \x04R\x0cblkNumberEnd\"S\n\x1arsp_getBlockDetailsByRange\x125\n\nblkDeta\
    ils\x18\x01\x20\x03(\x0b2\x15.bp_api.t_BlockDetailR\nblkDetails\"(\n\x0c\
    req_getNonce\x12\x18\n\x07address\x18\x01\x20\x01(\x0cR\x07address\"$\n\
    \x0crsp_getNonce\x12\x14\n\x05nonce\x18\x01\x20\x01(\x0cR\x05nonce\"-\n\
    \x0frsp_getNrgPrice\x12\x1a\n\x08nrgPrice\x18\x01\x20\x01(\x04R\x08nrgPr\
    ice\"9\n\x19req_getBlockDetailsByHash\x12\x1c\n\tblockHash\x18\x01\x20\
    \x01(\x0cR\tblockHash\"R\n\x19rsp_getBlockDetailsByHash\x125\n\nblkDetai\
    ls\x18\x01\x20\x01(\x0b2\x15.bp_api.t_BlockDetailR\nblkDetails\"1\n\rrsp\
    _listening\x12\x20\n\x0bisListening\x18\x01\x20\x01(\x08R\x0bisListening\
    \"%\n\rrsp_peerCount\x12\x14\n\x05peers\x18\x01\x20\x01(\rR\x05peers*\
    \x84\x01\n\x05Servs\x12\x08\n\x04s_hb\x10\0\x12\x0b\n\x07s_admin\x10\x01\
    \x12\x0b\n\x07s_chain\x10\x02\x12\r\n\ts_account\x10\x03\x12\x08\n\x04s_\
    tx\x10\x04\x12\t\n\x05s_net\x10\x05\x12\n\n\x06s_mine\x10\x06\x12\x0f\n\
    \x0bs_privilege\x10\x07\x12\x0c\n\x08s_wallet\x10\x08\x12\x08\n\x04s_NA\
    \x10\t*\x87\x0b\n\x05Funcs\x12\x15\n\x11f_protocolVersion\x10\0\x12\x12\
    \n\x0ef_minerAddress\x10\x01\x12\x0e\n\nf_accounts\x10\x02\x12\x11\n\rf_\
    blockNumber\x10\x03\x12\x10\n\x0cf_getBalance\x10\x04\x12\x12\n\x0ef_get\
    StorageAt\x10\x05\x12\x13\n\x0ff_unlockAccount\x10\x06\x12\x15\n\x11f_se\
    ndTransaction\x10\x07\x12\x1a\n\x16f_getTransactionByHash\x10\x08\x12\r\
    \n\tf_compile\x10\t\x12\x14\n\x10f_contractDeploy\x10\n\x12\x19\n\x15f_g\
    etTransactionCount\x10\x0b\x12$\n\x20f_getBlockTransactionCountByHash\
    \x10\x0c\x12&\n\"f_getBlockTransactionCountByNumber\x10\r\x12\r\n\tf_get\
    Code\x10\x0e\x12\n\n\x06f_call\x10\x0f\x12\x14\n\x10f_getBlockByHash\x10\
    \x10\x12\x16\n\x12f_getBlockByNumber\x10\x11\x12'\n#f_getTransactionByBl\
    ockHashAndIndex\x10\x12\x12)\n%f_getTransactionByBlockNumberAndIndex\x10\
    \x13\x12\x1b\n\x17f_getTransactionReceipt\x10\x14\x12\x12\n\x0ef_getComp\
    ilers\x10\x15\x12\x15\n\x11f_compileSolidity\x10\x16\x12\r\n\tf_getWork\
    \x10\x17\x12\x10\n\x0cf_submitWork\x10\x18\x12\x1d\n\x19f_fetchQueuedTra\
    nsactions\x10\x19\x12\x17\n\x13f_signedTransaction\x10\x1a\x12\x14\n\x10\
    f_rawTransaction\x10\x1b\x12\x11\n\rf_estimateNrg\x10\x1c\x12\x0c\n\x08f\
    _mining\x10\x1d\x12\x0e\n\nf_hashrate\x10\x1e\x12\x14\n\x10f_getActiveNo\
    des\x10\x1f\x12\x14\n\x10f_getSolcVersion\x10\x20\x12\x0f\n\x0bf_isSynci\
    ng\x10!\x12\x0e\n\nf_syncInfo\x10\"\x12\x13\n\x0ff_getSystemInfo\x10#\
    \x12\x13\n\x0ff_eventRegister\x10$\x12\x15\n\x11f_eventDeregister\x10%\
    \x12\x13\n\x0ff_accountCreate\x10&\x12\x11\n\rf_accountLock\x10'\x12\x13\
    \n\x0ff_userPrivilege\x10(\x12\x10\n\x0cf_eventQuery\x10)\x12\x14\n\x10f\
    _importAccounts\x10*\x12\x14\n\x10f_exportAccounts\x10+\x12\x1c\n\x18f_g\
    etBlockHeaderByNumber\x10,\x12\x1a\n\x16f_getBlockHeaderByHash\x10-\x12\
    \x1f\n\x1bf_getCurrentTotalDifficulty\x10.\x12\x14\n\x10f_getStaticNodes\
    \x10/\x12\x1d\n\x19f_getBlockDetailsByNumber\x100\x12\x1d\n\x19f_getBloc\
    kDetailsByLatest\x101\x12\x17\n\x13f_getBlocksByLatest\x102\x12$\n\x20f_\
    getAccountDetailsByAddressList\x103\x12\x14\n\x10f_backupAccounts\x104\
    \x12\x08\n\x04f_NA\x105\x12\x18\n\x14f_getBlockSqlByRange\x106\x12\x1c\n\
    \x18f_getBlockDetailsByRange\x107\x12\x0e\n\nf_getNonce\x108\x12\x11\n\r\
    f_getNrgPrice\x109\x12\x1b\n\x17f_getBlockDetailsByHash\x10:\x12\x0f\n\
    \x0bf_listening\x10;\x12\x0f\n\x0bf_peerCount\x10<*\xa1\x07\n\x07Retcode\
    \x12\n\n\x06r_fail\x10\0\x12\r\n\tr_success\x10\x01\x12\x13\n\x0fr_walle\
    t_nullcb\x10\x02\x12\x15\n\x11r_heartbeatReturn\x10\x03\x12\x15\n\x11r_p\
    rivilegeReturn\x10\x04\x12\r\n\tr_tx_Init\x10d\x12\x0f\n\x0br_tx_Recved\
    \x10e\x12\x10\n\x0cr_tx_Dropped\x10f\x12\x13\n\x0fr_tx_NewPending\x10g\
    \x12\x10\n\x0cr_tx_Pending\x10h\x12\x11\n\rr_tx_Included\x10i\x12\x10\n\
    \x0cr_tx_eventCb\x10j\x12\x08\n\x04r_NA\x10k\x12\x1e\n\x11r_fail_header_\
    len\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x20\n\x13r_fail_serv\
    ice_call\x10\xfe\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12!\n\x14r_fail_fu\
    nction_call\x10\xfd\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12&\n\x19r_fail\
    _function_exception\x10\xfc\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1f\
    \n\x12r_fail_api_version\x10\xfb\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\
    \x1f\n\x12r_fail_ct_bytecode\x10\xfa\xff\xff\xff\xff\xff\xff\xff\xff\x01\
    \x12\x1c\n\x0fr_fail_null_rsp\x10\xf9\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12\x20\n\x13r_fail_invalid_addr\x10\xf8\xff\xff\xff\xff\xff\xff\
    \xff\xff\x01\x12'\n\x1ar_fail_null_compile_source\x10\xf7\xff\xff\xff\
    \xff\xff\xff\xff\xff\x01\x12$\n\x17r_fail_compile_contract\x10\xf6\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12#\n\x16r_fail_sendTx_null_rep\x10\
    \xf5\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\x1e\n\x11r_fail_getcode_to\
    \x10\xf4\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12*\n\x1dr_fail_getTxRecei\
    pt_null_recp\x10\xf3\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12(\n\x1br_fai\
    l_zmqHandler_exception\x10\xf2\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12(\
    \n\x1br_fail_hit_pending_tx_limit\x10\xf1\xff\xff\xff\xff\xff\xff\xff\
    \xff\x01\x12%\n\x18r_fail_txqueue_exception\x10\xf0\xff\xff\xff\xff\xff\
    \xff\xff\xff\x01\x12&\n\x19r_fail_function_arguments\x10\xef\xff\xff\xff\
    \xff\xff\xff\xff\xff\x01\x12!\n\x14r_fail_unsupport_api\x10\xee\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x12\x1b\n\x0er_fail_unknown\x10\xed\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
